import React, { useState, useEffect, useRef } from 'react';
import {
  Mic,
  Paperclip, // Using Paperclip for file attachment icon
  Send,
  Upload, // Still useful for the actual upload button within the bubble
  StopCircle,
  Trash2,
  CheckCircle,
  XCircle,
  Edit3,
  FileText,
  Play, // Ensure this is correctly imported
} from 'lucide-react';
import { motion } from 'framer-motion';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Header } from '@/components/layout/Header';

export default function App() {
  return (
    <div className="flex flex-col h-screen bg-gray-50">
      <Header title="Import Financials (Chat Mode)" />
      <ChatInterface />
    </div>
  );
}

// --- New Component: EditableTransactionTable ---
// This component is now responsible for rendering the editable table
// It receives initial transactions and callbacks for confirm/cancel
const EditableTransactionTable = ({ transactions: initialTransactions, accounts, categories, onConfirm, onCancel }) => {
  const [transactions, setTransactions] = useState(initialTransactions);
  const [editingRowId, setEditingRowId] = useState(null);

  // Function to handle changes in the transaction table
  const handleTransactionChange = (id, field, value) => {
    setTransactions(prevData =>
      prevData.map(tx =>
        tx.id === id ? { ...tx, [field]: value } : tx
      )
    );
  };

  return (
    <div className="p-4 bg-white rounded-lg shadow-md">
      <h4 className="text-lg font-semibold mb-3">Review & Edit Transactions:</h4>
      <div className="overflow-x-auto max-h-[400px] overflow-y-auto">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Type</TableHead>
              <TableHead>Amount (R)</TableHead>
              <TableHead>Description</TableHead>
              <TableHead>Date</TableHead>
              <TableHead>Category</TableHead>
              <TableHead>Account</TableHead>
              <TableHead>Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {transactions.map((transaction) => (
              <TableRow key={transaction.id}>
                <TableCell>
                  {editingRowId === transaction.id ? (
                    <Select
                      value={transaction.type}
                      onValueChange={(value) => handleTransactionChange(transaction.id, 'type', value)}
                    >
                      <SelectTrigger className="w-[100px]">
                        <SelectValue placeholder="Type" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="income">Income</SelectItem>
                        <SelectItem value="expense">Expense</SelectItem>
                        <SelectItem value="debt">Debt</SelectItem>
                      </SelectContent>
                    </Select>
                  ) : (
                    transaction.type
                  )}
                </TableCell>
                <TableCell>
                  {editingRowId === transaction.id ? (
                    <Input
                      type="number"
                      step="0.01"
                      value={transaction.amount}
                      onChange={(e) => handleTransactionChange(transaction.id, 'amount', e.target.value)}
                      className="w-[100px]"
                    />
                  ) : (
                    parseFloat(transaction.amount).toFixed(2)
                  )}
                </TableCell>
                <TableCell className="max-w-[200px] truncate">
                  {editingRowId === transaction.id ? (
                    <Textarea
                      value={transaction.description}
                      onChange={(e) => handleTransactionChange(transaction.id, 'description', e.target.value)}
                      rows="2"
                      className="w-[200px]"
                    />
                  ) : (
                    transaction.description
                  )}
                </TableCell>
                <TableCell>
                  {editingRowId === transaction.id ? (
                    <Input
                      type="date"
                      value={transaction.date}
                      onChange={(e) => handleTransactionChange(transaction.id, 'date', e.target.value)}
                      className="w-[150px]"
                    />
                  ) : (
                    transaction.date
                  )}
                </TableCell>
                <TableCell>
                  {editingRowId === transaction.id ? (
                    <Select
                      value={transaction.category}
                      onValueChange={(value) => handleTransactionChange(transaction.id, 'category', value)}
                    >
                      <SelectTrigger className="w-[150px]">
                        <SelectValue placeholder="Category" />
                      </SelectTrigger>
                      <SelectContent>
                        {categories.map((cat) => (
                          <SelectItem key={cat} value={cat}>{cat}</SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    transaction.category
                  )}
                </TableCell>
                <TableCell>
                  {editingRowId === transaction.id ? (
                    <Select
                      value={transaction.account_id}
                      onValueChange={(value) => handleTransactionChange(transaction.id, 'account_id', value)}
                    >
                      <SelectTrigger className="w-[150px]">
                        <SelectValue placeholder="Account" />
                      </SelectTrigger>
                      <SelectContent>
                        {accounts.map((account) => (
                          <SelectItem key={account.id} value={String(account.id)}>{account.name} ({account.type})</SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    accounts.find(acc => String(acc.id) === String(transaction.account_id))?.name || 'N/A'
                  )}
                </TableCell>
                <TableCell className="flex space-x-2">
                  {editingRowId === transaction.id ? (
                    <>
                      <Button variant="outline" size="sm" onClick={() => setEditingRowId(null)} className="flex items-center">
                        <XCircle size={16} className="mr-1" /> Cancel
                      </Button>
                      <Button size="sm" onClick={() => setEditingRowId(null)} className="flex items-center">
                        <CheckCircle size={16} className="mr-1" /> Save
                      </Button>
                    </>
                  ) : (
                    <Button variant="outline" size="sm" onClick={() => setEditingRowId(transaction.id)} className="flex items-center">
                      <Edit3 size={16} className="mr-1" /> Edit
                    </Button>
                  )}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
      <div className="flex justify-end space-x-4 mt-4">
        <Button variant="secondary" onClick={onCancel}>
          <XCircle size={18} className="mr-2" /> Cancel Review
        </Button>
        <Button onClick={() => onConfirm(transactions)}>
          <CheckCircle size={18} className="mr-2" /> Confirm & Submit All
        </Button>
      </div>
    </div>
  );
};


// --- Main ChatInterface Component ---
const ChatInterface = () => {
  const RAIRO_API_BASE_URL = 'https://rairo-stmt-api.hf.space';
  const API_BASE_URL = 'https://quantnow-cu1v.onrender.com';

  const [messages, setMessages] = useState([]);
  const [accounts, setAccounts] = useState([]);
  const [typedDescription, setTypedDescription] = useState('');
  const [file, setFile] = useState(null); // Stores the actual file object
  const [isRecording, setIsRecording] = useState(false);
  const [audioBlob, setAudioBlob] = useState(null);
  const [audioUrl, setAudioUrl] = useState(null);
  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);
  const audioPlayerRef = useRef(null);
  const chatContainerRef = useRef(null);

  const [showProcessedTransactionReview, setShowProcessedTransactionReview] = useState(false);
  const [processedTransactionData, setProcessedTransactionData] = useState([]);

  const [showDocumentGeneration, setShowDocumentGeneration] = useState(false);
  const [selectedDocumentType, setSelectedDocumentType] = useState('');
  const [documentStartDate, setDocumentStartDate] = useState(new Date().toISOString().split('T')[0]);
  const [documentEndDate, setDocumentEndDate] = useState(new Date().toISOString().split('T')[0]);

  // New state for loading accounts
  const [isLoadingAccounts, setIsLoadingAccounts] = useState(true);

  const categories = [
    'Groceries', 'Rent', 'Utilities', 'Transport', 'Food', 'Salary', 'Deposit',
    'Loan', 'Debt Payment', 'Entertainment', 'Shopping', 'Healthcare', 'Education',
    'Travel', 'Investments', 'Insurance', 'Bills', 'Dining Out', 'Subscriptions', 'Other',
    'Sales', 'Interest Income', 'Cost of Goods Sold', 'Accounts Payable', 'Rent Expense',
    'Utilities Expenses', 'Car Loans', 'Sales Revenue', 'General Expense', 'Fees', 'Purchases', 'Refund',
    'Fuel', 'Salaries and wages', 'Projects Expenses', 'Accounting fees', 'Repairs & Maintenance',
    'Water and electricity', 'Bank charges', 'Insurance' // Added new categories from API
  ];

  // Scroll to bottom of chat messages when new message arrives
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [messages]);

  useEffect(() => {
    return () => {
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
    };
  }, [audioUrl]);

  useEffect(() => {
    const fetchAccounts = async () => {
      setIsLoadingAccounts(true); // Start loading
      try {
        const response = await fetch(`${API_BASE_URL}/accounts`);
        const data = await response.json();
        setAccounts(data);
        addAssistantMessage('Accounts loaded successfully. You can now import transactions.');
      } catch (error) {
        console.error('Failed to fetch accounts', error);
        addAssistantMessage('Failed to load accounts. Please ensure your backend server is running at `https://quantnow-cu1v.onrender.com`.');
      } finally {
        setIsLoadingAccounts(false); // End loading
      }
    };
    fetchAccounts();
  }, []);

  const addMessage = (sender, content) => {
    // Ensure unique key for messages
    setMessages(prev => [...prev, { id: `${Date.now()}-${Math.random()}`, sender, content }]);
  };

  const addAssistantMessage = (content) => {
    setMessages(prev => [...prev, { id: `${Date.now()}-${Math.random()}`, sender: 'assistant', content }]);
  };

  const addUserMessage = (content) => {
    setMessages(prev => [...prev, { id: `${Date.now()}-${Math.random()}`, sender: 'user', content }]);
  };

/**
 * Suggests the best matching account based on transaction details and available accounts.
 * Prioritizes specific keyword matches within category and description, then falls back to type.
 * @param {object} transaction - The transaction object (type, category, description).
 * @param {Array} accounts - The list of available accounts from the database (id, name, type, code).
 * @returns {string|null} The suggested account ID as a string, or null if no suggestion.
 */
const suggestAccount = (transaction, accounts) => {
  if (!accounts || accounts.length === 0) return null;

  // Helper: safely lowercase text
  const safeText = (txt?: string | null) => (txt ? txt.toLowerCase() : '');

  // Helper: safely check if any keyword exists in text
  const includesAny = (text: string, keywords: string[]) =>
    keywords.some(keyword => text.includes(keyword));

  // Extract safe, lowercased fields for matching
  const lowerTransactionType = safeText(transaction.type);
  const lowerCategory = safeText(transaction.category);
  const lowerDescription = safeText(transaction.description);

  // Helper to find an account by name keywords and optional type
  const findAccountByName = (nameKeywords: string[], accountType?: string) => {
    return accounts.find(acc => {
      const lowerAccName = safeText(acc.name);
      const typeMatch = accountType ? safeText(acc.type) === safeText(accountType) : true;
      return typeMatch && includesAny(lowerAccName, nameKeywords);
    });
  };

  // --- 1. Direct Category/Description to Account Name Matches (Highest Priority) ---

  // Expenses
  if (lowerTransactionType === 'expense') {
    if (includesAny(lowerCategory, ['fuel']) || includesAny(lowerDescription, ['fuel', 'petrol'])) {
      const acc = findAccountByName(['fuel expense'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['salaries and wages']) || includesAny(lowerDescription, ['salary', 'wages', 'payroll'])) {
      const acc = findAccountByName(['salaries and wages expense'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['projects expenses']) || includesAny(lowerDescription, ['project', 'materials', 'contractor'])) {
      const acc = findAccountByName(['projects expenses'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['accounting fees']) || includesAny(lowerDescription, ['accountant', 'audit', 'tax fee'])) {
      const acc = findAccountByName(['accounting fees expense'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['repairs & maintenance']) || includesAny(lowerDescription, ['repair', 'maintenance', 'fix', 'electrician'])) {
      const acc = findAccountByName(['repairs & maintenance expense'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['water and electricity']) || includesAny(lowerDescription, ['electricity', 'water bill', 'utilities'])) {
      const acc = findAccountByName(['water and electricity expense'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['bank charges']) || includesAny(lowerDescription, ['bank charge', 'service fee', 'card fee'])) {
      const acc = findAccountByName(['bank charges & fees'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['insurance']) || includesAny(lowerDescription, ['insurance', 'policy'])) {
      const acc = findAccountByName(['insurance expense'], 'expense');
      if (acc) return String(acc.id);
    }
    // Specific check for 'Other expenses' to map to 'Miscellaneous Expense'
    if (includesAny(lowerCategory, ['other expenses']) || includesAny(lowerDescription, ['misc', 'sundries', 'general expense'])) {
      const acc = findAccountByName(['miscellaneous expense'], 'expense'); // Prioritize 'Miscellaneous Expense'
      if (acc) return String(acc.id);
    }
    // General 'Other expenses' or 'Miscellaneous' - Ensure this is checked AFTER more specific ones
    if (includesAny(lowerCategory, ['miscellaneous']) || includesAny(lowerDescription, ['misc', 'sundries', 'general expense'])) {
        const acc = findAccountByName(['miscellaneous expense', 'general expense', 'other expenses'], 'expense');
        if (acc) return String(acc.id);
    }
    // Broader expense categories (keep these lower in priority than specific ones)
    if (includesAny(lowerCategory, ['rent']) || includesAny(lowerDescription, ['rent', 'rental'])) {
      const acc = findAccountByName(['rent expense'], 'expense');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['cost of goods sold', 'cogs']) || includesAny(lowerDescription, ['cost of goods sold', 'cogs', 'purchases'])) {
      // This is often for inventory purchases, not general expenses like fuel.
      // Ensure specific expense accounts are checked before this.
      const acc = findAccountByName(['cost of goods sold'], 'expense');
      if (acc) return String(acc.id);
    }
  }

  // Income
  if (lowerTransactionType === 'income') {
    if (includesAny(lowerCategory, ['sales', 'revenue']) || includesAny(lowerDescription, ['sale', 'revenue', 'customer payment'])) {
      const acc = findAccountByName(['sales revenue'], 'income');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['interest income']) || includesAny(lowerDescription, ['interest received', 'interest income'])) {
      const acc = findAccountByName(['interest income'], 'income');
      if (acc) return String(acc.id);
    }
    // For generic 'income' or 'general income' from API, try to map to 'Other Income' if available
    if (includesAny(lowerCategory, ['income', 'general income']) || includesAny(lowerDescription, ['transfer from', 'deposit'])) {
      const acc = findAccountByName(['other income'], 'income');
      if (acc) return String(acc.id);
    }
  }

  // Debt/Liability
  if (lowerTransactionType === 'debt') {
    if (includesAny(lowerCategory, ['car loans', 'loan repayment']) || includesAny(lowerDescription, ['car loan', 'vehicle finance'])) {
      const acc = findAccountByName(['car loans'], 'liability');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['loan', 'debt']) || includesAny(lowerDescription, ['loan', 'debt', 'borrow'])) {
      const acc = findAccountByName(['loan payable', 'long-term loan payable', 'short-term loan payable'], 'liability');
      if (acc) return String(acc.id);
    }
    if (includesAny(lowerCategory, ['accounts payable']) || includesAny(lowerDescription, ['payable', 'creditor'])) {
      const acc = findAccountByName(['accounts payable'], 'liability');
      if (acc) return String(acc.id);
    }
  }

  // Assets (for transfers, deposits, or asset purchases) - These rules are for the *other side* of a transaction
  // e.g., if an income transaction increases a bank account, or an expense decreases it.
  // The 'type' of the account (Asset) is distinct from the 'type' of the transaction (income/expense).
  if (includesAny(lowerCategory, ['bank', 'cash', 'deposit']) || includesAny(lowerDescription, ['bank', 'cash', 'deposit', 'transfer'])) {
    const acc = findAccountByName(['bank account', 'cash'], 'asset');
    if (acc) return String(acc.id);
  }
  if (includesAny(lowerCategory, ['equipment', 'property', 'asset purchase']) || includesAny(lowerDescription, ['equipment', 'machinery', 'property', 'asset purchase'])) {
    const acc = findAccountByName(['equipment', 'property, plant and equipment'], 'asset');
    if (acc) return String(acc.id);
  }
  if (includesAny(lowerCategory, ['accounts receivable']) || includesAny(lowerDescription, ['invoice payment received', 'customer payment'])) {
    const acc = findAccountByName(['accounts receivable'], 'asset');
    if (acc) return String(acc.id);
  }

  // --- 2. Fallback to General Account Types ---
  // If specific matches fail, try to match broadly by transaction type to account type
  if (lowerTransactionType === 'income') {
    const acc = accounts.find(acc => safeText(acc.type) === 'income');
    if (acc) return String(acc.id);
  }
  if (lowerTransactionType === 'expense') {
    const acc = accounts.find(acc => safeText(acc.type) === 'expense');
    if (acc) return String(acc.id);
  }
  if (lowerTransactionType === 'debt') {
    const acc = accounts.find(acc => safeText(acc.type) === 'liability');
    if (acc) return String(acc.id);
  }

  // --- 3. Final Fallback: General Bank Account or first available account ---
  const defaultBank = findAccountByName(['bank account'], 'asset');
  if (defaultBank) return String(defaultBank.id);

  const defaultCash = findAccountByName(['cash'], 'asset');
  if (defaultCash) return String(defaultCash.id);

  // As a very last resort, return the ID of the first account in the list
  // This assumes there's always at least one account, e.g., a default bank account.
  return accounts.length > 0 ? String(accounts[0].id) : null;
};


  const submitTransaction = async (dataToSubmit) => {
  // ✅ Ensure mandatory fields and include `id` if present
  const payload = {
    id: dataToSubmit.id || undefined, // <-- include ID for updates
    type: dataToSubmit.type || "expense",
    amount: dataToSubmit.amount ? parseFloat(dataToSubmit.amount) : 0,
    date: dataToSubmit.date || new Date().toISOString().split("T")[0],
    description: dataToSubmit.description || "Imported Transaction",
    category: dataToSubmit.category || "Uncategorized",
    account_id:
      dataToSubmit.account_id ||
      String(accounts[0]?.id || null), // fallback to first account if not mapped
    original_text: dataToSubmit.original_text || null, // Added
    source: dataToSubmit.source || 'manual', // Added
    confirmed: dataToSubmit.confirmed !== undefined ? dataToSubmit.confirmed : true // Added
  };

  console.log("Submitting transaction data:", payload);

  try {
    const response = await fetch(`${API_BASE_URL}/transactions/manual`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    const result = await response.json();

    if (response.ok) {
      return { success: true, transaction: result };
    } else {
      console.error("Submission error details:", result);
      return { success: false, error: result.detail || "Failed to submit transaction" };
    }
  } catch (error) {
    console.error("Error submitting transaction:", error);
    return { success: false, error: error.message || "Network error or server unavailable." };
  }
};


// ✅ Handle File Selection
const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const selectedFile = e.target.files?.[0] || null;

  if (!selectedFile) {
    addAssistantMessage("No file selected.");
    return;
  }

  if (selectedFile.type !== "application/pdf") {
    addAssistantMessage("Only PDF files are supported.");
    e.target.value = ""; // Reset input so user can pick again
    return;
  }

  setFile(selectedFile);
  setTypedDescription(`File: ${selectedFile.name}`);

  // ✅ Reset input value to allow re-selecting the same file
  e.target.value = "";
};
  const handleFileUpload = async () => {
    if (!file) {
      addAssistantMessage('No file selected for upload.');
      return;
    }

    if (file.type !== 'application/pdf') {
      addAssistantMessage('Only PDF files are supported for processing.');
      setFile(null); // Clear file if invalid type
      setTypedDescription(''); // Clear input
      return;
      }

    addUserMessage(`Initiating PDF upload: ${file.name}...`); // User confirms upload
    addAssistantMessage(`Processing PDF: ${file.name}...`);

    try {
      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch(`${RAIRO_API_BASE_URL}/process-pdf`, {
        method: 'POST',
        body: formData,
      });

      const result = await response.json();
      console.log('API Response for PDF:', result);

      if (response.ok) {
        addAssistantMessage('PDF processed successfully! Please review the extracted transactions.');
        
        const transformedTransactions = result.transactions.map((tx, idx) => {
          const transactionType = tx.Type?.toLowerCase() || "expense"; // Default to expense if type is missing
          let transactionCategory = tx.Destination_of_funds || "Uncategorized";

          // Refine category for income types if it's generic
          if (transactionType === 'income' && ['income', 'general income'].includes(transactionCategory.toLowerCase())) {
            transactionCategory = 'Sales Revenue'; // Or another appropriate default income category
          }

          const transaction = {
            id: `pdf-${idx}-${Date.now()}`,
            type: transactionType,
            amount: tx.Amount ? String(tx.Amount) : "0",
            description: tx.Description || "Imported Transaction",
            date: tx.Date
              ? new Date(tx.Date.split('/').reverse().join('-')).toISOString().split('T')[0]
              : new Date().toISOString().split('T')[0],
            category: transactionCategory, // Use the refined category
            account_id: suggestAccount({ type: transactionType, category: transactionCategory, description: tx.Description }, accounts) || String(accounts[0]?.id || ""),
            original_text: tx.Original_Text || (tx.Description || "Imported Transaction"), // Use description as original text if not provided
            source: 'pdf-upload', // Set source for PDF imports
            confirmed: true, // Default to true upon import
          };

          // Pass the current accounts state to suggestAccount
          transaction.account_id = suggestAccount(transaction, accounts);
          return transaction;
        });
        // Render the EditableTransactionTable directly in the chat
        addAssistantMessage(
          <EditableTransactionTable
            transactions={transformedTransactions}
            accounts={accounts}
            categories={categories}
            onConfirm={handleConfirmProcessedTransaction}
            onCancel={() => {
              addAssistantMessage('Transaction review cancelled.');
            }}
          />
        );

      } else {
        const errorMessage = `Error processing file: ${result.error || 'Unknown error'}`;
        addAssistantMessage(errorMessage);
      }
    } catch (error) {
      const errorMessage = `Network error during file upload: ${error.message || 'API is unavailable.'}`;
      console.error('Network error during file upload:', error);
      addAssistantMessage(errorMessage);
    } finally {
      setFile(null); // Clear the file object after processing
      setTypedDescription(''); // Clear input field after sending
    }
  };

  const handleTypedDescriptionSubmit = async () => {
    if (!typedDescription.trim()) {
      addAssistantMessage('Please enter a description.');
      return;
    }

    const userMessageContent = typedDescription;
    addUserMessage(userMessageContent);
    addAssistantMessage('Analyzing description...');
    setTypedDescription(''); // Clear input immediately

    try {
      const response = await fetch(`${RAIRO_API_BASE_URL}/process-text`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text: userMessageContent }),
      });

      const result = await response.json();

      if (response.ok) {
        addAssistantMessage('Description analyzed successfully! Please review the extracted transactions.');
        
        const transformedTransactions = result.transactions.map((tx, idx) => {
          const transactionType = tx.Type?.toLowerCase() || "expense"; // Default to expense if type is missing
          let transactionCategory = tx.Destination_of_funds || "Uncategorized";

          // Refine category for income types if it's generic
          if (transactionType === 'income' && ['income', 'general income'].includes(transactionCategory.toLowerCase())) {
            transactionCategory = 'Sales Revenue'; // Or another appropriate default income category
          }

          return {
            id: tx.id || `pdf-${idx}-${Date.now()}`,  // ✅ keep ID if backend already provided it
            type: transactionType,
            amount: tx.Amount ? String(tx.Amount) : "0",
            description: tx.Description || "Imported Transaction",
            date: tx.Date
              ? new Date(tx.Date.split("/").reverse().join("-")).toISOString().split("T")[0]
              : new Date().toISOString().split("T")[0],
            category: transactionCategory, // Use the refined category
            account_id: suggestAccount({ type: transactionType, category: transactionCategory, description: tx.Description }, accounts) || String(accounts[0]?.id || ""),
            original_text: userMessageContent, // Original text is the user's typed description
            source: 'text-input', // Set source for text input
            confirmed: true, // Default to true upon import
          };
        });

        // Render the EditableTransactionTable directly in the chat
        addAssistantMessage(
          <EditableTransactionTable
            transactions={transformedTransactions}
            accounts={accounts}
            categories={categories}
            onConfirm={handleConfirmProcessedTransaction}
            onCancel={() => {
              addAssistantMessage('Transaction review cancelled.');
            }}
          />
        );

      } else {
        const errorMessage = `Error analyzing description: ${result.error || 'Unknown error'}`;
        addAssistantMessage(errorMessage);
      }
    } catch (error) {
      const errorMessage = `Network error during text processing: ${error.message || 'API is unavailable.'}`;
      console.error('Network error during text processing:', error);
      addAssistantMessage(errorMessage);
    }
  };

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorderRef.current = new MediaRecorder(stream);
      audioChunksRef.current = [];

      mediaRecorderRef.current.ondataavailable = (event) => {
        audioChunksRef.current.push(event.data);
      };

      mediaRecorderRef.current.onstop = () => {
        const blob = new Blob(audioChunksRef.current, { type: 'audio/wav' });
        setAudioBlob(blob);
        setAudioUrl(URL.createObjectURL(blob));
        if (audioPlayerRef.current) {
          audioPlayerRef.current.src = ''; // Clear src after recording stops
          audioPlayerRef.current.load(); // Load the new blob
          audioPlayerRef.current.src = URL.createObjectURL(blob); // Set src again to play
        }
        stream.getTracks().forEach(track => track.stop());
      };

      mediaRecorderRef.current.start();
      setIsRecording(true);
      addUserMessage('Started audio recording...');
    } catch (err) {
      console.error('Error accessing microphone:', err);
      addAssistantMessage('Failed to access microphone. Please check permissions.');
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
      addUserMessage('Stopped audio recording.');
    }
  };

  const uploadAudio = async () => {
    if (!audioBlob) {
      addAssistantMessage('No audio recorded to upload.');
      return;
    }

    addUserMessage('Processing recorded audio...');
    
    try {
      const simulatedTranscribedText = "I paid fifty dollars for groceries on July fifth, two thousand twenty-five. I also received 1200 salary on the same day.";
      
      const processTextResponse = await fetch(`${RAIRO_API_BASE_URL}/process-text`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text: simulatedTranscribedText }),
      });
      const result = await processTextResponse.json();

      if (processTextResponse.ok) {
        addAssistantMessage('Audio processed successfully! Please review the extracted transactions.');
        
        const transformedTransactions = result.transactions.map((tx, idx) => {
          const transactionType = tx.Type === 'income' ? 'income' : 'expense';
          let transactionCategory = tx.Destination_of_funds;

          // Refine category for income types if it's generic
          if (transactionType === 'income' && ['income', 'general income'].includes(transactionCategory?.toLowerCase())) {
            transactionCategory = 'Sales Revenue'; // Or another appropriate default income category
          }

          return {
            id: `audio-${idx}-${Date.now()}`, // Ensure unique ID for transactions
            type: transactionType,
            amount: String(tx.Amount),
            description: tx.Description,
            date: new Date(tx.Date.split('/').reverse().join('-')).toISOString().split('T')[0],
            category: transactionCategory, // Use the refined category
            account_id: suggestAccount({ type: transactionType, category: transactionCategory, description: tx.Description }, accounts) || String(accounts[0]?.id || ""),
            original_text: simulatedTranscribedText, // Original text is the transcribed audio
            source: 'audio-input', // Set source for audio input
            confirmed: true, // Default to true upon import
          };
        });
        // Render the EditableTransactionTable directly in the chat
        addAssistantMessage(
          <EditableTransactionTable
            transactions={transformedTransactions}
            accounts={accounts}
            categories={categories}
            onConfirm={handleConfirmProcessedTransaction}
            onCancel={() => {
              addAssistantMessage('Transaction review cancelled.');
            }}
          />
        );

      } else {
        const errorMessage = `Error processing audio: ${result.error || 'Unknown error'}`;
        addAssistantMessage(errorMessage);
      }
    } catch (error) {
      const errorMessage = `Network error during audio processing: ${error.message || 'API is unavailable.'}`;
      console.error('Network error during audio processing:', error);
      addAssistantMessage(errorMessage);
    } finally {
      setAudioBlob(null);
      setAudioUrl(null);
      if (audioPlayerRef.current) {
        audioPlayerRef.current.src = '';
      }
    }
  };

  const clearAudio = () => {
    setAudioBlob(null);
    setAudioUrl(null);
    if (audioPlayerRef.current) {
      audioPlayerRef.current.src = '';
    }
    addAssistantMessage('Audio cleared.');
  };

const handleConfirmProcessedTransaction = async (transactionsToSave) => {
  addAssistantMessage("Submitting transactions...");

  const updatedTransactions = await Promise.all(
    transactionsToSave.map(async (transaction) => {
      const { success, transaction: savedTransaction } = await submitTransaction(transaction);
      return success ? { ...transaction, id: savedTransaction.id } : transaction;
    })
  );

  setProcessedTransactionData(updatedTransactions); // ✅ update table with new IDs

  const allSuccessful = updatedTransactions.every((tx) => tx.id);
  if (allSuccessful) {
    addAssistantMessage(`Successfully submitted ${transactionsToSave.length} transactions.`);
    setShowDocumentGeneration(true);
  } else {
    addAssistantMessage("Some transactions failed. Check console for details.");
  }
};

  const handleGenerateFinancialDocument = () => {
    if (!selectedDocumentType) {
      addAssistantMessage('Please select a document type to generate.');
      return;
    }
    if (!documentStartDate || !documentEndDate) {
      addAssistantMessage('Please select both start and end dates for the document.');
      return;
    }

    const downloadUrl = `${API_BASE_URL}/generate-financial-document?documentType=${selectedDocumentType}&startDate=${documentStartDate}&endDate=${documentEndDate}`;
    
    addUserMessage(`Please generate a ${selectedDocumentType} for the period ${documentStartDate} to ${documentEndDate}.`);
    addAssistantMessage(
      <div className="p-4 bg-blue-100 rounded-md shadow-sm">
        <p className="font-semibold mb-2">Generating your financial document...</p>
        <p className="text-sm">If the download does not start automatically, click the button below:</p>
        <a
          href={downloadUrl}
          target="_blank"
          rel="noopener noreferrer"
          className="mt-3 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          onClick={() => addAssistantMessage('Download initiated!')}
        >
          <FileText size={18} className="mr-2" /> Download {selectedDocumentType.replace('-', ' ').toUpperCase()}
        </a>
      </div>
    );

    setSelectedDocumentType('');
    setDocumentStartDate(new Date().toISOString().split('T')[0]);
    setDocumentEndDate(new Date().toISOString().split('T')[0]);
    setShowDocumentGeneration(false);
  };

  // Unified send logic for the main input bar
  const handleUnifiedSend = () => {
    if (file) {
      handleFileUpload();
    } else if (typedDescription.trim()) {
      // Check for commands like /audio, /text, /upload
      if (typedDescription.startsWith('/audio')) {
        addAssistantMessage("Please use the microphone icon to record audio, then click play to process.");
        setTypedDescription('');
      } else if (typedDescription.startsWith('/upload')) {
        // This command doesn't directly trigger upload, it's just a hint
        addAssistantMessage("Please use the paperclip icon to select a file, then click Send.");
        setTypedDescription('');
      } else if (typedDescription.startsWith('/text')) {
        // Remove '/text' command from the description before sending to API
        const textToProcess = typedDescription.substring('/text'.length).trim();
        if (textToProcess) {
          setTypedDescription(textToProcess); // Temporarily set for handleTypedDescriptionSubmit
          handleTypedDescriptionSubmit();
        } else {
          addAssistantMessage("Please provide a description after '/text'.");
          setTypedDescription('');
        }
      } else {
        handleTypedDescriptionSubmit(); // Default to text analysis
      }
    } else {
      // If nothing is typed and no file is selected, do nothing or show a message
      addAssistantMessage("Please type a message or select a file to proceed.");
    }
  };


  return (
    <>
      {/* Chat Messages Display Area */}
      <div ref={chatContainerRef} className="flex-1 overflow-y-auto p-4 space-y-4">
        {/* Loading message for accounts */}
        {isLoadingAccounts && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
            className="flex justify-start"
          >
            <div className="max-w-[70%] p-3 rounded-2xl shadow-md bg-gray-200 text-gray-800">
              Loading accounts...
            </div>
          </motion.div>
        )}
        {messages.map((msg) => (
          <motion.div
            key={msg.id} // Unique key for each message
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
            className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}
          >
            <div className={`max-w-[70%] p-3 rounded-2xl shadow-md ${msg.sender === 'user' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-800'}`}>
              {/* Render JSX directly if it's an element, otherwise render string */}
              {typeof msg.content === 'string' ? msg.content : msg.content}
            </div>
          </motion.div>
        ))}

        {/* Document Generation Section (appears after transactions are submitted) */}
        {showDocumentGeneration && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
            className="mt-8 p-6 bg-white rounded-xl shadow-lg border border-gray-200 self-center w-full max-w-md mx-auto"
          >
            <h3 className="text-xl font-bold text-gray-800 mb-4">Generate Financial Document</h3>
            <div className="space-y-4">
              <div>
                <Label htmlFor="documentType">Document Type</Label>
                <Select
                  id="documentType"
                  value={selectedDocumentType}
                  onValueChange={setSelectedDocumentType}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select Document Type" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="income-statement">Income Statement</SelectItem>
                    <SelectItem value="balance-sheet">Balance Sheet</SelectItem>
                    <SelectItem value="trial-balance">Trial Balance</SelectItem>
                    <SelectItem value="cash-flow-statement">Cash Flow Statement</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="documentStartDate">Start Date</Label>
                  <Input
                    type="date"
                    id="documentStartDate"
                    value={documentStartDate}
                    onChange={(e) => setDocumentStartDate(e.target.value)}
                  />
                </div>
                <div>
                  <Label htmlFor="documentEndDate">End Date</Label>
                  <Input
                    type="date"
                    id="documentEndDate"
                    value={documentEndDate}
                    onChange={(e) => setDocumentEndDate(e.target.value)}
                  />
                </div>
              </div>
              <Button
                onClick={handleGenerateFinancialDocument}
                className="w-full inline-flex justify-center py-3 px-6 border border-transparent shadow-sm text-base font-medium rounded-md text-white bg-green-600 hover:bg-green-700"
              >
                <FileText size={18} className="mr-2" /> Generate Document
              </Button>
            </div>
          </motion.div>
        )}
      </div>

      {/* Chat Input Area */}
      <div className="p-4 bg-white border-t shadow flex items-center space-x-2">
        {/* File Upload Button */}
        <label htmlFor="file-upload-input" className="cursor-pointer">
          <Input
            id="file-upload-input"
            type="file"
            className="sr-only"
            onChange={handleFileChange}
            accept=".pdf"
            disabled={isLoadingAccounts} // Disable when loading accounts
          />
          <Button
            asChild
            variant="ghost"
            className="rounded-full p-2 text-gray-600 hover:bg-gray-100"
            aria-label="Attach File"
            disabled={isLoadingAccounts} // Disable when loading accounts
          >
          <span>
          <Paperclip size={20} className="text-gray-600" />
          </span>
          </Button>
        </label>

        {/* Audio Recording Buttons */}
        {isRecording ? (
          <Button
            onClick={stopRecording}
            variant="ghost"
            className="rounded-full p-2 text-red-500 hover:bg-red-100 animate-pulse"
            aria-label="Stop Recording"
            disabled={isLoadingAccounts} // Disable when loading accounts
          >
            <StopCircle size={20} />
          </Button>
        ) : (
          <Button
            onClick={startRecording}
            variant="ghost"
            className="rounded-full p-2 text-purple-600 hover:bg-purple-100"
            aria-label="Start Recording"
            disabled={isLoadingAccounts} // Disable when loading accounts
          >
            <Mic size={20} />
          </Button>
        )}
        {audioUrl && (
          <>
            <audio ref={audioPlayerRef} src={audioUrl} controls className="hidden"></audio>
            <Button
              onClick={uploadAudio}
              variant="ghost"
              className="rounded-full p-2 text-green-600 hover:bg-green-100"
              aria-label="Process Audio"
              disabled={isLoadingAccounts} // Disable when loading accounts
            >
              <Play size={20} />
            </Button>
            <Button
              onClick={clearAudio}
              variant="ghost"
              className="rounded-full p-2 text-gray-600 hover:bg-gray-100"
              aria-label="Clear Audio"
              disabled={isLoadingAccounts} // Disable when loading accounts
            >
              <Trash2 size={20} />
            </Button>
          </>
        )}

        <Input
          type="text"
          className="flex-1 border rounded-full px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder={isLoadingAccounts ? "Loading accounts..." : "Type a transaction description or command (/audio, /text)..."}
          value={typedDescription}
          onChange={(e) => setTypedDescription(e.target.value)}
          onKeyPress={(e) => {
            if (e.key === 'Enter' && (typedDescription.trim() || file)) {
              handleUnifiedSend();
            }
          }}
          disabled={isLoadingAccounts} // Disable when loading accounts
        />
        <Button
          onClick={handleUnifiedSend}
          disabled={!typedDescription.trim() && !file && !isRecording && !audioBlob || isLoadingAccounts} // Disable if no text, no file, not recording, no audio blob, or loading accounts
          className="p-2 bg-blue-600 text-white rounded-full hover:bg-blue-700"
          aria-label="Send Message"
        >
          <Send size={20} />
        </Button>
      </div>
    </>
  );
};



import dotenv from 'dotenv';
dotenv.config()

import express from 'express';
import cors from 'cors';
import { Pool } from 'pg';
import multer from 'multer';
import nodemailer from 'nodemailer';

/* import { v4 as uuidv4 } from 'uuid'; */ // Not used in this version

const app = express();
const PORT = 3000;
const PDFDocument = require('pdfkit'); // For PDF generation

app.use(cors()); // Enable CORS for all routes
app.use(express.json()); // Enable JSON body parsing

const pool = new Pool({
  connectionString: 'postgresql://postgres:123qwe@localhost/q_analytix',
});

// Test database connection
pool.connect((err, client, release) => {
    if (err) {
        return console.error('Error acquiring client', err.stack);
    }
    // Ensure client is defined before using it
    if (client) {
        client.query('SELECT NOW()', (queryErr, result) => {
            release();
            if (queryErr) {
                return console.error('Error executing query', queryErr.stack);
            }
            console.log('Connected to PostgreSQL database:', result.rows[0].now);
        });
    } else {
        release(); // Release the client even if it's undefined (shouldn't happen with successful connect)
        console.error('Client is undefined after successful pool.connect');
    }
});

// Configure Nodemailer transporter with OAuth2
const transporter = nodemailer.createTransport({
    host: process.env.EMAIL_SERVICE_HOST,
    port: Number(process.env.EMAIL_SERVICE_PORT),
    secure: Number(process.env.EMAIL_SERVICE_PORT) === 465, // true for 465 (SSL/TLS)
    auth: {
        user: process.env.EMAIL_SERVICE_USER,
        pass: process.env.EMAIL_SERVICE_PASS, // <--- Use the App Password here
    },
});

// Optional: Verify transporter connection (good for debugging)
transporter.verify(function (error, success) {
    if (error) {
        console.error("Nodemailer transporter verification failed:", error);
    } else {
        console.log("Nodemailer transporter is ready to send messages.");
    }
});

// --- Generic Email Sending Function ---
interface EmailOptions {
  to: string;
  subject: string;
  text?: string;
  html?: string;
  attachments?: nodemailer.SendMailOptions['attachments'];
}

async function sendEmail(options: EmailOptions) {
  try {
    const info = await transporter.sendMail({
      from: `"${process.env.APP_NAME || 'Your Company'}" <${process.env.EMAIL_SERVICE_USER}>`,
      to: options.to,
      subject: options.subject,
      text: options.text,
      html: options.html,
      attachments: options.attachments,
    });
    console.log('Email sent successfully! Message ID: %s', info.messageId);
    return true; // Indicate success
  } catch (error) {
    console.error('Failed to send email:', error);
    if (error instanceof Error) {
        console.error('Error name:', error.name);
        console.error('Error message:', error.message);
        // @ts-ignore // Nodemailer specific properties
        if (error.responseCode) console.error('Response Code:', error.responseCode);
        // @ts-ignore
        if (error.response) console.error('Response:', error.response);
    }
    return false; // Indicate failure
  }
}

app.use(cors());
app.use(express.json());

const upload = multer({ storage: multer.memoryStorage() }); // Use memory storage for file uploads

/* --- Type Definitions (Minimal, but necessary for ts-node) --- */
/* Placing them here ensures they are available before the routes use them */

interface SupplierDB { // Represents how data comes from the DB (public.suppliers table)
    id: number;
    name: string;
    email: string | null;
    phone: string | null;
    address: string | null;
    vat_number: string | null; // Matches DB column name
    total_purchased: number; // Matches DB column name, NOT NULL with default 0.00
    created_at?: Date;
    updated_at?: Date;
}

// Utility function to map DB schema to frontend interface
const mapSupplierToFrontend = (supplier: SupplierDB) => ({
    id: supplier.id.toString(), // Convert number ID to string for React
    name: supplier.name,
    email: supplier.email || '', // Ensure it's a string, not null
    phone: supplier.phone || '',
    address: supplier.address || '',
    vatNumber: supplier.vat_number || '', // Map snake_case to camelCase
    totalPurchased: supplier.total_purchased, // Map snake_case to camelCase
});
// Add these interfaces and the mapping function near your SupplierDB and mapSupplierToFrontend

// Interface matching the public.products_services table structure
interface ProductDB {
    id: number;
    name: string;
    description: string | null;
    unit_price: number; // From DB
    cost_price: number | null;
    sku: string | null;
    is_service: boolean;
    stock_quantity: number; // From DB
    created_at: Date;
    updated_at: Date;
    tax_rate_id: number | null; // Foreign key
    category: string | null;
    unit: string | null;
    // Potentially include the tax rate itself from the joined table
    tax_rate_value?: number; // The actual rate (e.g., 0.15) from tax_rates table
}

// Interface for what the frontend expects (camelCase)
interface ProductFrontend {
    id: string; // React often prefers string IDs
    name: string;
    description: string; // Frontend might expect string, even if DB has null
    price: number;
    costPrice?: number; // Optional for frontend if not always displayed
    sku?: string; // Optional for frontend
    isService: boolean; // camelCase
    stock: number; // camelCase
    vatRate: number; // Actual percentage (e.g., 0.15)
    category: string;
    unit: string;
}

// Interface for what the frontend sends when creating/updating a product
// Note: id and totalPurchased (if any, though not for products) are excluded.
// vatRate is the *value*, not the ID.
interface CreateUpdateProductBody {
    name: string;
    description?: string;
    price: number; // Corresponds to unit_price
    costPrice?: number;
    sku?: string;
    isService?: boolean;
    stock?: number; // Corresponds to stock_quantity
    vatRate?: number; // The actual tax rate value (e.g., 0.15)
    category?: string;
    unit?: string;
}

// Helper function to map database product object to frontend product object
const mapProductToFrontend = (product: ProductDB): ProductFrontend => ({
    id: product.id.toString(),
    name: product.name,
    description: product.description || '', // Ensure it's a string for frontend
    price: Number(product.unit_price), // Convert numeric to number
    costPrice: product.cost_price ? Number(product.cost_price) : undefined,
    sku: product.sku || undefined,
    isService: product.is_service,
    stock: Number(product.stock_quantity), // Convert numeric to number
    vatRate: product.tax_rate_value !== undefined && product.tax_rate_value !== null ? Number(product.tax_rate_value) : 0, // Default to 0 if null/undefined
    category: product.category || '',
    unit: product.unit || '',
});
interface CustomerDB {
    id: number;
    name: string;
    contact_person: string | null;
    email: string | null;
    phone: string | null;
    address: string | null;
    tax_id: string | null; // Matches DB column name
    total_invoiced: number; // Matches DB column name
    created_at?: Date;
    updated_at?: Date;
}

// Interface for what the frontend expects (camelCase)
interface CustomerFrontend {
    id: string; // React often prefers string IDs
    name: string;
    email: string;
    phone: string;
    address: string;
    vatNumber: string; // camelCase, maps to tax_id
    totalInvoiced: number; // camelCase, maps to total_invoiced
}

// Interface for what the frontend sends when creating/updating a customer
// contactPerson and vatNumber are camelCase for frontend consistency
interface CreateUpdateCustomerBody {
    name: string;
    contactPerson?: string; // Maps to contact_person
    email?: string;
    phone?: string;
    address?: string;
    vatNumber?: string; // Maps to tax_id
}

// Helper function to map database customer object to frontend customer object
const mapCustomerToFrontend = (customer: CustomerDB): CustomerFrontend => ({
    id: customer.id.toString(), // Convert number ID to string
    name: customer.name,
    email: customer.email || '',
    phone: customer.phone || '',
    address: customer.address || '',
    vatNumber: customer.tax_id || '', // Map tax_id to vatNumber
    totalInvoiced: Number(customer.total_invoiced), // Ensure it's a number
});
 export interface ProductService {
  id: string;
  name: string;
  description: string;
  price: number; // This is 'price' (number) from ProductFrontend, not 'unit_price' (string) from DB
  costPrice?: number;
  sku?: string;
  isService: boolean;
  stock: number;
  vatRate: number; // Decimal (e.g., 0.15)
  category: string;
  unit: string;
}


// Generic PDF generation endpoint for invoices and statements
// Generic PDF generation endpoint for invoices and statements
// server.ts (excerpt)

app.get('/api/:documentType/:id/pdf', async (req, res) => {
  const { documentType, id } = req.params;

  try {
    const doc = new PDFDocument({ margin: 50 });
    let filename = `${documentType}_${id}.pdf`;

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

    doc.pipe(res);

    switch (documentType) {
      case 'invoice': {
        // ... existing invoice generation logic ...
        break;
      }
      case 'receipt': {
        // ... existing receipt generation logic ...
        break;
      }
      case 'statement': {
        // ... existing statement generation logic ...
        break;
      }
      // NEW CASE: Handle Quotation PDF generation
      case 'quotation': {
        const quotationResult = await pool.query(
          `SELECT
            q.id, q.quotation_number, q.customer_id, c.name AS customer_name, c.email AS customer_email,
            q.quotation_date, q.expiry_date, q.total_amount, q.status, q.currency, q.notes,
            q.created_at, q.updated_at
          FROM quotations q
          JOIN customers c ON q.customer_id = c.id
          WHERE q.id = $1`,
          [id]
        );

        if (quotationResult.rows.length === 0) {
          res.writeHead(404, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Quotation not found' }));
          doc.end();
          return;
        }

        const quotation = quotationResult.rows[0];

        const lineItemsResult = await pool.query(
          `SELECT
            qi.id, qi.product_service_id, ps.name AS product_service_name,
            qi.description, qi.quantity, qi.unit_price, qi.line_total, qi.tax_rate
          FROM quotation_line_items qi
          LEFT JOIN product_services ps ON qi.product_service_id = ps.id
          WHERE qi.quotation_id = $1
          ORDER BY qi.id`,
          [id]
        );
        quotation.line_items = lineItemsResult.rows;

        // --- PDF Content for Quotation ---
        doc.fontSize(24).text('Quotation', { align: 'center' });
        doc.moveDown();

        doc.fontSize(12).text(`Quotation #: ${quotation.quotation_number}`);
        doc.text(`Date: ${new Date(quotation.quotation_date).toLocaleDateString('en-GB')}`);
        if (quotation.expiry_date) {
          doc.text(`Expiry Date: ${new Date(quotation.expiry_date).toLocaleDateString('en-GB')}`);
        }
        doc.moveDown();

        doc.fontSize(14).text('Bill To:', { underline: true });
        doc.fontSize(12).text(quotation.customer_name);
        doc.text(quotation.customer_email); // Assuming customer_email is available
        doc.moveDown();

        // Line Items Table
        const tableTop = doc.y;
        const col1X = 50;
        const col2X = 180;
        const col3X = 280;
        const col4X = 350;
        const col5X = 420;
        const col6X = 500;
        const columnWidth = 70;

        doc.font('Helvetica-Bold').fontSize(10);
        doc.text('Description', col1X, tableTop, { width: columnWidth * 2 });
        doc.text('Qty', col3X, tableTop, { width: columnWidth, align: 'right' });
        doc.text('Unit Price', col4X, tableTop, { width: columnWidth, align: 'right' });
        doc.text('Tax Rate', col5X, tableTop, { width: columnWidth, align: 'right' });
        doc.text('Line Total', col6X, tableTop, { width: columnWidth, align: 'right' });
        doc.moveDown();

        doc.font('Helvetica').fontSize(10);
        let currentY = doc.y;

        quotation.line_items.forEach((item: any) => {
          doc.text(item.description, col1X, currentY, { width: columnWidth * 2 });
          doc.text(item.quantity.toString(), col3X, currentY, { width: columnWidth, align: 'right' });
          doc.text(`R${(item.unit_price ?? 0).toFixed(2)}`, col4X, currentY, { width: columnWidth, align: 'right' });
          doc.text(`${((item.tax_rate ?? 0) * 100).toFixed(2)}%`, col5X, currentY, { width: columnWidth, align: 'right' });
          doc.text(`R${(item.line_total ?? 0).toFixed(2)}`, col6X, currentY, { width: columnWidth, align: 'right' });
          currentY += 20; // Adjust line height as needed
        });

        doc.moveDown();

        // Totals
        doc.font('Helvetica-Bold').fontSize(12).text(`Total Amount: ${quotation.currency} ${(quotation.total_amount ?? 0).toLocaleString('en-ZA', { minimumFractionDigits: 2 })}`, { align: 'right' });
        doc.moveDown();

        if (quotation.notes) {
          doc.fontSize(10).text('Notes:', { underline: true });
          doc.text(quotation.notes);
        }

        break;
      }
      default:
        doc.text('Document type not supported.', { align: 'center' });
        doc.end();
        return;
    }

    doc.end();

  } catch (error: unknown) {
    console.error(`Error generating ${documentType}:`, error);
    res.removeHeader('Content-Disposition');
    res.writeHead(500, { 'Content-Type': 'application/json' });

    if (error instanceof Error) {
      res.end(JSON.stringify({ error: `Failed to generate ${documentType}`, details: error.message }));
    } else {
      res.end(JSON.stringify({ error: `Failed to generate ${documentType}`, details: String(error) }));
    }
  }
});

// Inside your server.ts, ideally within your API routes section
app.get('/api/quotations/:id/pdf', async (req, res) => {
    const { id } = req.params;
    const doc = new PDFDocument({ margin: 50 });

    try {
        const quotationQueryResult = await pool.query(
            `SELECT
                q.*,
                c.name AS customer_name,
                c.email AS customer_email
            FROM quotations q
            JOIN customers c ON q.customer_id = c.id
            WHERE q.id = $1`,
            [id]
        );

        if (quotationQueryResult.rows.length === 0) {
            res.status(404).json({ error: 'Quotation not found' });
            doc.end();
            return;
        }

        const quotation = quotationQueryResult.rows[0];

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="quotation_${quotation.quotation_number}.pdf"`);

        doc.pipe(res);

        // Fetch line items for the quotation
        const lineItemsResult = await pool.query(
            `SELECT
                li.*,
                ps.name AS product_service_name
            FROM quotation_line_items li
            LEFT JOIN product_services ps ON li.product_service_id = ps.id
            WHERE li.quotation_id = $1
            ORDER BY li.created_at`,
            [id]
        );
        quotation.line_items = lineItemsResult.rows;

        // --- PDF Content Generation for Quotation (adapt from invoice) ---
        doc.fontSize(24).font('Helvetica-Bold').text('Quotation', { align: 'center' });
        doc.moveDown(1.5);

        doc.fontSize(12).font('Helvetica-Bold').text('Quotation Details:', { underline: true });
        doc.font('Helvetica')
            .text(`Quotation Number: ${quotation.quotation_number}`)
            .text(`Customer: ${quotation.customer_name}`)
            .text(`Quotation Date: ${new Date(quotation.quotation_date).toLocaleDateString('en-GB')}`)
            .text(`Expiry Date: ${quotation.expiry_date ? new Date(quotation.expiry_date).toLocaleDateString('en-GB') : 'N/A'}`);
        doc.moveDown(1.5);

        doc.fontSize(14).font('Helvetica-Bold').text('Line Items:', { underline: true });
        doc.moveDown(0.5);

        // Table Headers (adjust columns as per quotation_line_items schema)
        const tableTop = doc.y;
        const col1X = 50; // Description
        const col2X = 250; // Qty
        const col3X = 300; // Unit Price
        const col4X = 400; // Tax Rate
        const col5X = 470; // Line Total

        doc.fontSize(10)
            .font('Helvetica-Bold')
            .text('Description', col1X, tableTop)
            .text('Qty', col2X, tableTop)
            .text('Unit Price', col3X, tableTop, { width: 70, align: 'right' })
            .text('Tax Rate', col4X, tableTop, { width: 60, align: 'right' })
            .text('Line Total', col5X, tableTop, { width: 70, align: 'right' });

        doc.lineWidth(0.5).strokeColor('#cccccc').moveTo(col1X, tableTop + 15).lineTo(550, tableTop + 15).stroke();

        let yPos = tableTop + 25;

        // Line Items Table Rows
        quotation.line_items.forEach((item: any) => {
            if (yPos + 20 > doc.page.height - doc.page.margins.bottom) {
                doc.addPage();
                yPos = doc.page.margins.top;
                doc.fontSize(10)
                    .font('Helvetica-Bold')
                    .text('Description', col1X, yPos)
                    .text('Qty', col2X, yPos)
                    .text('Unit Price', col3X, yPos, { width: 70, align: 'right' })
                    .text('Tax Rate', col4X, yPos, { width: 60, align: 'right' })
                    .text('Line Total', col5X, yPos, { width: 70, align: 'right' });
                doc.lineWidth(0.5).strokeColor('#cccccc').moveTo(col1X, yPos + 15).lineTo(550, yPos + 15).stroke();
                yPos += 25;
            }

            doc.fontSize(10).font('Helvetica')
                .text(item.description, col1X, yPos, { width: 190 })
                .text(item.quantity.toString(), col2X, yPos, { width: 40, align: 'right' })
                .text(`R${(parseFloat(item.unit_price)).toFixed(2)}`, col3X, yPos, { width: 70, align: 'right' })
                .text(`${(parseFloat(item.tax_rate) * 100).toFixed(2)}%`, col4X, yPos, { width: 60, align: 'right' })
                .text(`R${(parseFloat(item.line_total)).toFixed(2)}`, col5X, yPos, { width: 70, align: 'right' });
            yPos += 20;
        });

        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#cccccc').moveTo(col1X, yPos).lineTo(550, yPos).stroke();

        yPos += 10;
        doc.fontSize(14).font('Helvetica-Bold')
            .text(`Total Amount: ${quotation.currency} ${(parseFloat(quotation.total_amount)).toFixed(2)}`, col1X, yPos, { align: 'right', width: 500 });

        if (quotation.notes) {
            doc.moveDown(1.5);
            doc.fontSize(10).font('Helvetica-Oblique').text(`Notes: ${quotation.notes}`);
        }

        doc.end();
    } catch (error: unknown) {
        console.error(`Error generating quotation PDF:`, error);
        if (res.headersSent) {
            console.error('Headers already sent. Cannot send JSON error for PDF generation error.');
            doc.end();
            return;
        }
        res.status(500).json({
            error: `Failed to generate quotation PDF`,
            details: error instanceof Error ? error.message : String(error)
        });
        doc.end();
    }
});

// Add this interface definition near your existing InvoiceDetailsForPdf interface
interface QuotationDetailsForPdf {
  quotation_number: string;
  customer_name: string;
  customer_email?: string; // Optional for PDF itself
  customer_address?: string; // If you fetch customer address
  quotation_date: string;
  expiry_date?: string; // Optional for quotation
  total_amount: number;
  currency: string;
  notes?: string;
  line_items: Array<{
    product_service_name?: string;
    description: string;
    quantity: number;
    unit_price: number;
    line_total: number;
    tax_rate: number;
  }>;
  companyName: string; // From your .env or DB
  companyAddress?: string; // Add if you want to display company address on quotation
  companyVat?: string; // Add if you want to display company VAT on quotation
}

// Add this function definition near your existing generateInvoicePdf function
async function generateQuotationPdf(quotationData: QuotationDetailsForPdf): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50 });
    const buffers: Buffer[] = [];

    doc.on('data', buffers.push.bind(buffers));
    doc.on('end', () => resolve(Buffer.concat(buffers)));
    doc.on('error', reject);

    // Header (Company details)
    doc.fontSize(24).font('Helvetica-Bold').text(quotationData.companyName, { align: 'right' });
    if (quotationData.companyAddress) {
      doc.fontSize(10).font('Helvetica').text(quotationData.companyAddress, { align: 'right' });
    }
    if (quotationData.companyVat) {
      doc.fontSize(10).font('Helvetica').text(`VAT No: ${quotationData.companyVat}`, { align: 'right' });
    }
    doc.moveDown(1);
    doc.fontSize(10).text(`Quotation Date: ${new Date(quotationData.quotation_date).toLocaleDateString('en-ZA')}`, { align: 'right' });
    if (quotationData.expiry_date) {
      doc.fontSize(10).text(`Expiry Date: ${new Date(quotationData.expiry_date).toLocaleDateString('en-ZA')}`, { align: 'right' });
    }
    doc.moveDown(2);

    // Title
    doc.fontSize(30).font('Helvetica-Bold').text(`QUOTATION #${quotationData.quotation_number}`, { align: 'center' });
    doc.moveDown(2);

    // Customer Details
    doc.fontSize(12).font('Helvetica-Bold').text('Quotation For:');
    doc.fontSize(12).font('Helvetica').text(quotationData.customer_name);
    if (quotationData.customer_address) {
      doc.fontSize(10).text(quotationData.customer_address);
    }
    if (quotationData.customer_email) {
      doc.fontSize(10).text(quotationData.customer_email);
    }
    doc.moveDown(2);

    // Table Header
    const tableTop = doc.y;
    const itemCol = 50;
    const descCol = 150;
    const qtyCol = 320;
    const priceCol = 370;
    const taxCol = 430;
    const totalCol = 500;

    doc.font('Helvetica-Bold').fontSize(10);
    doc.text('Item', itemCol, tableTop);
    doc.text('Description', descCol, tableTop);
    doc.text('Qty', qtyCol, tableTop, { width: 50, align: 'right' });
    doc.text('Unit Price', priceCol, tableTop, { width: 50, align: 'right' });
    doc.text('Tax', taxCol, tableTop, { width: 50, align: 'right' });
    doc.text('Line Total', totalCol, tableTop, { width: 50, align: 'right' });

    doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(itemCol, tableTop + 15).lineTo(doc.page.width - 50, tableTop + 15).stroke();
    doc.moveDown();

    // Table Body
    doc.font('Helvetica').fontSize(9);
    let currentY = doc.y;
    let subtotal = 0;
    let totalTax = 0;

    quotationData.line_items.forEach(item => {
      currentY = doc.y;
      const itemDescription = item.product_service_name || item.description;
      const taxAmount = (item.line_total * item.tax_rate);
      const lineTotalExclTax = item.line_total - taxAmount;

      doc.text(itemDescription, itemCol, currentY, { width: 140 });
      doc.text(item.description, descCol, currentY, { width: 160 }); // Full description if needed
      doc.text(item.quantity.toString(), qtyCol, currentY, { width: 50, align: 'right' });
      doc.text(formatCurrency(item.unit_price, ''), priceCol, currentY, { width: 50, align: 'right' });
      doc.text(`${(item.tax_rate * 100).toFixed(0)}%`, taxCol, currentY, { width: 50, align: 'right' });
      doc.text(formatCurrency(item.line_total, ''), totalCol, currentY, { width: 50, align: 'right' });

      doc.moveDown();
      subtotal += lineTotalExclTax;
      totalTax += taxAmount;
    });

    // Totals
    doc.moveDown();
    const totalsY = doc.y;
    doc.font('Helvetica-Bold').fontSize(10);

    doc.text('Subtotal:', 400, totalsY, { width: 80, align: 'right' });
    doc.text(formatCurrency(subtotal, quotationData.currency), 500, totalsY, { width: 50, align: 'right' });
    doc.moveDown();

    doc.text('Tax:', 400, doc.y, { width: 80, align: 'right' });
    doc.text(formatCurrency(totalTax, quotationData.currency), 500, doc.y, { width: 50, align: 'right' });
    doc.moveDown();

    doc.fontSize(14).text('Total Amount:', 400, doc.y, { width: 80, align: 'right' });
    doc.text(formatCurrency(quotationData.total_amount, quotationData.currency), 500, doc.y, { width: 50, align: 'right' });
    doc.moveDown(3);

    // Notes
    if (quotationData.notes) {
      doc.fontSize(10).font('Helvetica-Bold').text('Notes:');
      doc.font('Helvetica').fontSize(10).text(quotationData.notes, { align: 'left' });
      doc.moveDown(2);
    }

    // Footer
    doc.fontSize(10).text(`Thank you for considering our quotation!`, doc.page.width / 2, doc.page.height - 50, {
      align: 'center',
      width: doc.page.width - 100,
    });

    doc.end();
  });
}

// Replace your existing /api/quotations/:id/send-pdf-email endpoint with this corrected version
app.post('/api/quotations/:id/send-pdf-email', upload.none(), async (req, res) => {
  const { id } = req.params;
  const { recipientEmail, subject, body } = req.body;

  if (!recipientEmail || !subject || !body) {
    return res.status(400).json({ error: 'Recipient email, subject, and body are required.' });
  }

  try {
    // Fetch quotation details to generate PDF
    const quotationQueryResult = await pool.query(
      `SELECT
          q.*,
          c.name AS customer_name,
          c.email AS customer_email,
          c.address AS customer_address
       FROM quotations q
       JOIN customers c ON q.customer_id = c.id
       WHERE q.id = $1`,
      [id]
    );

    if (quotationQueryResult.rows.length === 0) {
      return res.status(404).json({ error: 'Quotation not found.' });
    }
    const quotation = quotationQueryResult.rows[0];

    const lineItemsResult = await pool.query(
      `SELECT
          li.*,
          ps.name AS product_service_name
       FROM quotation_line_items li
       LEFT JOIN products_services ps ON li.product_service_id = ps.id
       WHERE li.quotation_id = $1
       ORDER BY li.created_at`,
      [id]
    );
    quotation.line_items = lineItemsResult.rows;

    // Prepare data for PDF generation
    const quotationDataForPdf: QuotationDetailsForPdf = {
      quotation_number: quotation.quotation_number,
      customer_name: quotation.customer_name,
      customer_email: quotation.customer_email,
      customer_address: quotation.customer_address, // Include customer address if available
      quotation_date: quotation.quotation_date,
      expiry_date: quotation.expiry_date,
      total_amount: parseFloat(quotation.total_amount),
      currency: quotation.currency,
      notes: quotation.notes,
      line_items: quotation.line_items.map((item: any) => ({
        product_service_name: item.product_service_name,
        description: item.description,
        quantity: parseFloat(item.quantity),
        unit_price: parseFloat(item.unit_price),
        line_total: parseFloat(item.line_total),
        tax_rate: parseFloat(item.tax_rate),
      })),
      companyName: process.env.APP_NAME || 'Your Company',
      // Add more company details from .env if you have them, e.g.:
      // companyAddress: process.env.COMPANY_ADDRESS,
      // companyVat: process.env.COMPANY_VAT_NUMBER,
    };

    // Generate PDF Buffer using the new function
    const pdfBuffer = await generateQuotationPdf(quotationDataForPdf);

    // Send email with PDF attachment
    const emailSent = await sendEmail({
      to: recipientEmail,
      subject: subject,
      html: body,
      attachments: [
        {
          filename: `Quotation_${quotation.quotation_number}.pdf`,
          content: pdfBuffer,
          contentType: 'application/pdf',
        },
      ],
    });

    if (emailSent) {
      res.status(200).json({ message: 'Email sent successfully!' });
    } else {
      res.status(500).json({ error: 'Failed to send quotation email.' });
    }

  } catch (error: unknown) {
    console.error('Error in send-pdf-email endpoint:', error);
    if (res.headersSent) {
      console.error('Headers already sent in send-pdf-email. Cannot send JSON error.');
      return;
    }
    if (error instanceof Error) {
      res.status(500).json({ error: 'Failed to process email request', details: error.message });
    } else {
      res.status(500).json({ error: 'Failed to process email request', details: String(error) });
    }
  }
});

/* --- Transactions API (Fetching) --- */
app.get('/transactions', async (req, res) => {
  // Get query parameters. Renamed 'filter' to 'category' for clarity and consistency with frontend.
  const { type, category, accountId, search, fromDate, toDate } = req.query;

  // --- NEW VALIDATION ---
  // This block checks if fromDate is after toDate. If so, it returns an empty array
  // gracefully, preventing a server error from an invalid date range query to the DB.
  if (fromDate && toDate && typeof fromDate === 'string' && typeof toDate === 'string') {
    const parsedFromDate = new Date(fromDate);
    const parsedToDate = new Date(toDate);
    if (parsedFromDate > parsedToDate) {
      console.warn(`Invalid date range requested: fromDate (${fromDate}) is after toDate (${toDate}). Returning empty transactions.`);
      return res.json([]); // Return empty array and exit
    }
  }
  // --- END NEW VALIDATION ---

  let query = `
    SELECT
      t.id,
      t.type,
      t.amount,
      t.description,
      t.date,
      t.category,
      t.created_at,
      t.account_id,
      t.original_text,
      t.source,
      t.confirmed,
      acc.name AS account_name,
      acc.type AS account_type -- Include account type for potential future filtering
    FROM
      transactions t
    LEFT JOIN
      accounts acc ON t.account_id = acc.id
    WHERE 1=1
  `;

  const queryParams: (string | number)[] = [];
  let paramIndex = 1;

  // --- NEW: Filter by Transaction Type (income/expense) ---
  if (type && typeof type === 'string' && type !== 'all') {
    query += ` AND t.type = $${paramIndex++}`;
    queryParams.push(type);
  }

  // --- UPDATED: Filter by Category (previously 'filter') ---
  if (category && typeof category === 'string' && category !== 'all') {
    query += ` AND t.category = $${paramIndex++}`;
    queryParams.push(category);
  }

  // --- NEW: Filter by Account ID ---
  if (accountId && typeof accountId === 'string' && accountId !== 'all') {
    // If you want to filter by 'Revenue Accounts' specifically,
    // you'd check for a special value like 'revenue_accounts' here
    // and add a condition like `AND acc.type = 'Revenue'`.
    // For now, it filters by specific account ID.
    query += ` AND t.account_id = $${paramIndex++}`;
    queryParams.push(accountId);
  }

  if (search && typeof search === 'string') {
    // Search across description, transaction type, or account name
    query += ` AND (t.description ILIKE $${paramIndex} OR t.type ILIKE $${paramIndex} OR acc.name ILIKE $${paramIndex})`;
    queryParams.push(`%${search}%`);
  }

  if (fromDate && typeof fromDate === 'string') {
    query += ` AND t.date >= $${paramIndex++}`;
    queryParams.push(fromDate);
  }

  if (toDate && typeof toDate === 'string') {
    query += ` AND t.date <= $${paramIndex++}`;
    queryParams.push(toDate);
  }

  query += ` ORDER BY t.date DESC, t.created_at DESC`; // Order by date, then creation time

  try {
    const result = await pool.query(query, queryParams);
    res.json(result.rows);
  } catch (error: unknown) {
    console.error('Error fetching transactions:', error);
    res.status(500).json({ error: 'Failed to fetch transactions', detail: error instanceof Error ? error.message : String(error) });
  }
});

app.post('/transactions/manual', async (req, res) => {
  const { id, type, amount, description, date, category, account_id, original_text, source, confirmed } = req.body; // Now expecting 'id', 'original_text', 'source', 'confirmed' as well

  if (!type || !amount || !date) {
    return res.status(400).json({ detail: 'type, amount, and date are required' });
  }

  try {
    let result;
    if (id) {
      // If ID is provided, perform an UPDATE
      result = await pool.query(
        `UPDATE transactions
         SET
           "type" = $1,
           amount = $2,
           description = $3,
           "date" = $4,
           category = $5,
           account_id = $6,
           original_text = $7, // Added
           source = $8,        // Added
           confirmed = $9      // Added
         WHERE id = $10
         RETURNING id, "type", amount, description, "date", category, account_id, created_at, original_text, source, confirmed`,
        [type, amount, description || null, date, category || null, account_id || null, original_text || null, source || 'manual', confirmed !== undefined ? confirmed : true, id]
      );
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Transaction not found for update' });
      }
    } else {
      // If no ID, perform an INSERT
      result = await pool.query(
        `INSERT INTO transactions ("type", amount, description, "date", category, account_id, original_text, source, confirmed)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, "type", amount, description, "date", category, account_id, created_at, original_text, source, confirmed`,
        [type, amount, description || null, date, category || null, account_id || null, original_text || null, source || 'manual', confirmed !== undefined ? confirmed : true]
      );
    }

    // Fetch the full transaction with account_name for consistent response
    const fullTransaction = await pool.query(`
      SELECT
        t.id, t.type, t.amount, t.description, t.date, t.category, t.created_at, t.account_id, t.original_text, t.source, t.confirmed, acc.name AS account_name
      FROM
        transactions t
      LEFT JOIN
        accounts acc ON t.account_id = acc.id
      WHERE t.id = $1
    `, [result.rows[0].id]);

    res.json(fullTransaction.rows[0]); // Return the full updated/inserted transaction
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('DB operation error:', error);
    res.status(500).json({ detail: 'Failed to perform transaction operation', error: error instanceof Error ? error.message : String(error) });
  }
});
/* --- Accounts API --- */
app.get('/accounts', async (req, res) => {
  try {
    // Select 'type' and 'code' to match frontend's expected Account interface
    const result = await pool.query('SELECT id, name, type, code FROM accounts ORDER BY id');
    res.json(result.rows);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error fetching accounts:', error);
    res.status(500).json({ error: 'Failed to fetch accounts', detail: error instanceof Error ? error.message : String(error) });
  }
});

app.post('/accounts', async (req, res) => {
  // Expect 'type', 'name', and 'code' from the frontend
  const { type, name, code } = req.body;

  // Validate all required fields based on your DB schema
  if (!type || !name || !code) {
    return res.status(400).json({ error: 'Missing required account fields: type, name, code' });
  }

  try {
    const insert = await pool.query(
      // Insert into 'type', 'name', 'code' columns
      `INSERT INTO accounts (type, name, code) VALUES ($1, $2, $3) RETURNING id`,
      [type, name, code]
    );
    const insertedId = insert.rows[0].id;

    const fullAccount = await pool.query(
      // Select the inserted account, including 'type' and 'code'
      `SELECT id, name, type, code FROM accounts WHERE id = $1`,
      [insertedId]
    );
    res.json(fullAccount.rows[0]);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error adding account:', error);
    res.status(500).json({ error: 'Failed to add account', detail: error instanceof Error ? error.message : String(error) });
  }
});

const formatCurrency = (amount: number, currency: string = 'R'): string => {
  return `${currency}${amount.toLocaleString('en-ZA', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
};

interface InvoiceDetailsForPdf {
  invoice_number: string;
  customer_name: string;
  customer_email?: string; // Optional for PDF itself
  customer_address?: string;
  invoice_date: string;
  due_date: string;
  total_amount: number;
  currency: string;
  notes?: string;
  line_items: Array<{
    product_service_name?: string;
    description: string;
    quantity: number;
    unit_price: number;
    line_total: number;
    tax_rate: number;
  }>;
  companyName: string; // From your .env or DB
  companyAddress?: string;
  companyVat?: string;
}

async function generateInvoicePdf(invoiceData: InvoiceDetailsForPdf): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50 });
    const buffers: Buffer[] = [];

    doc.on('data', buffers.push.bind(buffers));
    doc.on('end', () => resolve(Buffer.concat(buffers)));
    doc.on('error', reject);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text(invoiceData.companyName, { align: 'right' });
    if (invoiceData.companyAddress) {
      doc.fontSize(10).font('Helvetica').text(invoiceData.companyAddress, { align: 'right' });
    }
    if (invoiceData.companyVat) {
      doc.fontSize(10).font('Helvetica').text(`VAT No: ${invoiceData.companyVat}`, { align: 'right' });
    }
    doc.moveDown(1);
    doc.fontSize(10).text(`Invoice Date: ${new Date(invoiceData.invoice_date).toLocaleDateString('en-ZA')}`, { align: 'right' });
    doc.fontSize(10).text(`Due Date: ${new Date(invoiceData.due_date).toLocaleDateString('en-ZA')}`, { align: 'right' });
    doc.moveDown(2);

    // Title
    doc.fontSize(30).font('Helvetica-Bold').text(`INVOICE #${invoiceData.invoice_number}`, { align: 'center' });
    doc.moveDown(2);

    // Bill To
    doc.fontSize(12).font('Helvetica-Bold').text('Bill To:');
    doc.fontSize(12).font('Helvetica').text(invoiceData.customer_name);
    if (invoiceData.customer_address) {
      doc.fontSize(10).text(invoiceData.customer_address);
    }
    if (invoiceData.customer_email) {
      doc.fontSize(10).text(invoiceData.customer_email);
    }
    doc.moveDown(2);

    // Table Header
    const tableTop = doc.y;
    const itemCol = 50;
    const descCol = 150;
    const qtyCol = 320;
    const priceCol = 370;
    const taxCol = 430;
    const totalCol = 500;

    doc.font('Helvetica-Bold').fontSize(10);
    doc.text('Item', itemCol, tableTop);
    doc.text('Description', descCol, tableTop);
    doc.text('Qty', qtyCol, tableTop, { width: 50, align: 'right' });
    doc.text('Price', priceCol, tableTop, { width: 50, align: 'right' });
    doc.text('Tax', taxCol, tableTop, { width: 50, align: 'right' });
    doc.text('Total', totalCol, tableTop, { width: 50, align: 'right' });

    doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(itemCol, tableTop + 15).lineTo(doc.page.width - 50, tableTop + 15).stroke();
    doc.moveDown();

    // Table Body
    doc.font('Helvetica').fontSize(9);
    let currentY = doc.y;
    let subtotal = 0;
    let totalTax = 0;

    invoiceData.line_items.forEach(item => {
      currentY = doc.y;
      const itemDescription = item.product_service_name || item.description;
      const taxAmount = (item.line_total * item.tax_rate);
      const lineTotalExclTax = item.line_total - taxAmount;

      doc.text(itemDescription, itemCol, currentY, { width: 140 });
      doc.text(item.description, descCol, currentY, { width: 160 }); // Full description if needed
      doc.text(item.quantity.toString(), qtyCol, currentY, { width: 50, align: 'right' });
      doc.text(formatCurrency(item.unit_price, ''), priceCol, currentY, { width: 50, align: 'right' });
      doc.text(`${(item.tax_rate * 100).toFixed(0)}%`, taxCol, currentY, { width: 50, align: 'right' });
      doc.text(formatCurrency(item.line_total, ''), totalCol, currentY, { width: 50, align: 'right' });

      doc.moveDown();
      subtotal += lineTotalExclTax;
      totalTax += taxAmount;
    });

    // Totals
    doc.moveDown();
    const totalsY = doc.y;
    doc.font('Helvetica-Bold').fontSize(10);

    doc.text('Subtotal:', 400, totalsY, { width: 80, align: 'right' });
    doc.text(formatCurrency(subtotal, invoiceData.currency), 500, totalsY, { width: 50, align: 'right' });
    doc.moveDown();

    doc.text('Tax:', 400, doc.y, { width: 80, align: 'right' });
    doc.text(formatCurrency(totalTax, invoiceData.currency), 500, doc.y, { width: 50, align: 'right' });
    doc.moveDown();

    doc.fontSize(14).text('Total Due:', 400, doc.y, { width: 80, align: 'right' });
    doc.text(formatCurrency(invoiceData.total_amount, invoiceData.currency), 500, doc.y, { width: 50, align: 'right' });
    doc.moveDown(3);

    // Notes
    if (invoiceData.notes) {
      doc.fontSize(10).font('Helvetica-Bold').text('Notes:');
      doc.font('Helvetica').fontSize(10).text(invoiceData.notes, { align: 'left' });
      doc.moveDown(2);
    }

    // Footer
    doc.fontSize(10).text(`Thank you for your business!`, doc.page.width / 2, doc.page.height - 50, {
      align: 'center',
      width: doc.page.width - 100,
    });

    doc.end();
  });
}

app.post('/api/invoices/:id/send-pdf-email', async (req, res) => {
  const invoiceId = req.params.id;
  const { customerEmail } = req.body; // Expect customerEmail in the request body

  if (!customerEmail) {
    return res.status(400).json({ error: 'Customer email is required to send the invoice.' });
  }

  try {
    // 1. Fetch Invoice Details from Database (including line items and customer info)
    const invoiceResult = await pool.query(
      `SELECT
          i.id, i.invoice_number, i.invoice_date, i.due_date, i.total_amount, i.status, i.currency, i.notes,
          c.name AS customer_name, c.email AS customer_email, c.address AS customer_address
       FROM public.invoices i
       JOIN public.customers c ON i.customer_id = c.id
       WHERE i.id = $1;`,
      [invoiceId]
    );

    if (invoiceResult.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found.' });
    }
    const invoice = invoiceResult.rows[0];

    const lineItemsResult = await pool.query(
      `SELECT
          il.product_service_id, il.description, il.quantity, il.unit_price, il.line_total, il.tax_rate,
          ps.name AS product_service_name
       FROM public.invoice_line_items il
       LEFT JOIN public.products_services ps ON il.product_service_id = ps.id
       WHERE il.invoice_id = $1;`,
      [invoiceId]
    );
    invoice.line_items = lineItemsResult.rows;

    // Prepare data for PDF generation
    const invoiceDataForPdf: InvoiceDetailsForPdf = {
      invoice_number: invoice.invoice_number,
      customer_name: invoice.customer_name,
      customer_email: invoice.customer_email,
      customer_address: invoice.customer_address,
      invoice_date: invoice.invoice_date,
      due_date: invoice.due_date,
      total_amount: parseFloat(invoice.total_amount),
      currency: invoice.currency,
      notes: invoice.notes,
      line_items: invoice.line_items.map((item: any) => ({
        product_service_name: item.product_service_name,
        description: item.description,
        quantity: parseFloat(item.quantity),
        unit_price: parseFloat(item.unit_price),
        line_total: parseFloat(item.line_total),
        tax_rate: parseFloat(item.tax_rate),
      })),
      companyName: process.env.APP_NAME || 'Your Company',
      // Add more company details from .env if you have them, e.g.:
      // companyAddress: process.env.COMPANY_ADDRESS,
      // companyVat: process.env.COMPANY_VAT_NUMBER,
    };

    // 2. Generate PDF
    const pdfBuffer = await generateInvoicePdf(invoiceDataForPdf);

    // 3. Send Email with PDF attachment
    const emailSubject = `Invoice #${invoice.invoice_number} from ${process.env.APP_NAME || 'Your Company'}`;
    const emailHtml = `
      <p>Dear ${invoice.customer_name},</p>
      <p>Please find attached your invoice (Invoice ID: <b>#${invoice.invoice_number}</b>) from ${process.env.APP_NAME || 'Your Company'}.</p>
      <p>Total amount due: <b>${formatCurrency(invoiceDataForPdf.total_amount, invoiceDataForPdf.currency)}</b></p>
      <p>Due Date: ${new Date(invoice.due_date).toLocaleDateString('en-ZA')}</p>
      <p>Thank you for your business!</p>
      <p>Sincerely,<br>${process.env.APP_NAME || 'Your Company'}</p>
    `;

    const emailSent = await sendEmail({
      to: customerEmail,
      subject: emailSubject,
      html: emailHtml,
      attachments: [
        {
          filename: `Invoice_${invoice.invoice_number}.pdf`,
          content: pdfBuffer,
          contentType: 'application/pdf',
        },
      ],
    });

    if (emailSent) {
      // Optional: Update invoice status to 'Sent' in your DB
      await pool.query(
        `UPDATE public.invoices SET status = 'Sent', updated_at = CURRENT_TIMESTAMP WHERE id = $1;`,
        [invoiceId]
      );
      res.status(200).json({ message: 'Invoice PDF generated and email sent successfully!' });
    } else {
      res.status(500).json({ error: 'Failed to send invoice email.' });
    }

  } catch (error: any) {
    console.error('Error generating PDF or sending email:', error);
    res.status(500).json({
      error: 'Failed to generate PDF or send email.',
      detail: error.message || String(error)
    });
  }
});
/* --- Assets API --- */

// Updated Asset Interface to include depreciation fields
interface Asset {
  id: string;
  type: string;
  name: string;
  number?: string;
  cost: number;
  date_received: string;
  account_id: string;
  account_name: string;
  depreciation_method?: string; // New
  useful_life_years?: number;   // New
  salvage_value?: number;       // New
  accumulated_depreciation: number; // New
  last_depreciation_date?: string; // New
}

app.get('/assets', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT
        a.id,
        a.type,
        a.name,
        a.number,
        a.cost,
        a.date_received,
        a.account_id,
        acc.name AS account_name,
        a.depreciation_method,      
        a.useful_life_years,        
        a.salvage_value,            
        a.accumulated_depreciation, 
        a.last_depreciation_date    
      FROM assets a
      JOIN accounts acc ON a.account_id = acc.id
      ORDER BY a.date_received DESC
    `);
    res.json(result.rows);
  } catch (error: unknown) {
    console.error('Error fetching assets:', error);
    res.status(500).json({ error: 'Failed to fetch assets', detail: error instanceof Error ? error.message : String(error) });
  }
});

app.post('/assets', async (req, res) => {
  const {
    type, name, number, cost, date_received, account_id,
    depreciation_method, useful_life_years, salvage_value
  } = req.body;

  if (!type || !name || cost == null || !date_received || !account_id) {
    return res.status(400).json({ error: 'Missing required asset fields: type, name, cost, date_received, account_id' });
  }

  try {
    const insert = await pool.query(
      `INSERT INTO assets (
        type, name, number, cost, date_received, account_id,
        depreciation_method, useful_life_years, salvage_value, accumulated_depreciation, last_depreciation_date
       )
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id`,
      [
        type, name, number || null, cost, date_received, account_id,
        depreciation_method || null, useful_life_years || null, salvage_value || null,
        0.00, // Initialize accumulated_depreciation to 0
        null  // Initialize last_depreciation_date to null
      ]
    );
    const insertedId = insert.rows[0].id;

    const fullAsset = await pool.query(`
      SELECT
        a.id, a.type, a.name, a.number, a.cost, a.date_received, a.account_id, acc.name AS account_name,
        a.depreciation_method, a.useful_life_years, a.salvage_value, a.accumulated_depreciation, a.last_depreciation_date
      FROM assets a
      JOIN accounts acc ON a.account_id = acc.id
      WHERE a.id = $1
    `, [insertedId]);

    res.json(fullAsset.rows[0]);
  } catch (error: unknown) {
    console.error('Error adding asset:', error);
    res.status(500).json({ error: 'Failed to add asset', detail: error instanceof Error ? error.message : String(error) });
  }
});

app.put('/assets/:id', async (req, res) => {
  const { id } = req.params;
  const {
    type, name, number, cost, date_received, account_id,
    depreciation_method, useful_life_years, salvage_value, accumulated_depreciation, last_depreciation_date
  } = req.body;

  const updates = [];
  const values = [];
  let paramIndex = 1;

  if (type !== undefined) { updates.push(`type = $${paramIndex++}`); values.push(type); }
  if (name !== undefined) { updates.push(`name = $${paramIndex++}`); values.push(name); }
  if (number !== undefined) { updates.push(`number = $${paramIndex++}`); values.push(number || null); }
  if (cost !== undefined) { updates.push(`cost = $${paramIndex++}`); values.push(cost); }
  if (date_received !== undefined) { updates.push(`date_received = $${paramIndex++}`); values.push(date_received); }
  if (account_id !== undefined) { updates.push(`account_id = $${paramIndex++}`); values.push(account_id); }
  if (depreciation_method !== undefined) { updates.push(`depreciation_method = $${paramIndex++}`); values.push(depreciation_method || null); }
  if (useful_life_years !== undefined) { updates.push(`useful_life_years = $${paramIndex++}`); values.push(useful_life_years || null); }
  if (salvage_value !== undefined) { updates.push(`salvage_value = $${paramIndex++}`); values.push(salvage_value || null); }
  if (accumulated_depreciation !== undefined) { updates.push(`accumulated_depreciation = $${paramIndex++}`); values.push(accumulated_depreciation); }
  if (last_depreciation_date !== undefined) { updates.push(`last_depreciation_date = $${paramIndex++}`); values.push(last_depreciation_date || null); }

  if (updates.length === 0) {
    return res.status(400).json({ error: 'No fields provided for update.' });
  }

  values.push(id); // Add ID for WHERE clause

  try {
    const result = await pool.query(
      `UPDATE assets SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Asset not found' });
    }
    res.json(result.rows[0]);
  } catch (error: unknown) {
    console.error('Error updating asset:', error);
    res.status(500).json({ error: 'Failed to update asset', detail: error instanceof Error ? error.message : String(error) });
  }
});


/* --- Depreciation API --- */

// Helper function to calculate straight-line depreciation for a period
const calculateDepreciation = (
  cost: number,
  salvageValue: number,
  usefulLifeYears: number,
  startDate: Date,
  endDate: Date
): number => {
  if (usefulLifeYears <= 0) return 0;

  const depreciableBase = cost - salvageValue;
  const annualDepreciation = depreciableBase / usefulLifeYears;
  const monthlyDepreciation = annualDepreciation / 12;

  // Calculate number of months in the period
  let monthsToDepreciate = 0;
  let currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);

  while (currentMonth <= endDate) {
    monthsToDepreciate++;
    currentMonth.setMonth(currentMonth.getMonth() + 1);
  }

  return monthlyDepreciation * monthsToDepreciate;
};


app.post('/api/depreciation/run', async (req, res) => {
  const { endDate } = req.body; // endDate: The date up to which depreciation should be calculated

  if (!endDate) {
    return res.status(400).json({ error: 'endDate is required for depreciation calculation.' });
  }

  const calculationEndDate = new Date(endDate);
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Fetch all assets that are depreciable and haven't been depreciated up to the endDate
    const assetsResult = await client.query(`
      SELECT
        id, cost, useful_life_years, salvage_value, date_received, accumulated_depreciation, last_depreciation_date
      FROM assets
      WHERE
        depreciation_method = 'straight-line' AND useful_life_years IS NOT NULL AND useful_life_years > 0
        AND (last_depreciation_date IS NULL OR last_depreciation_date < $1)
    `, [calculationEndDate.toISOString().split('T')[0]]); // Compare only date part

    const depreciatedAssets: { assetId: number; amount: number; transactionId: number }[] = [];
    let totalDepreciationExpense = 0;
    let defaultExpenseAccountId: number | null = null;

    // Try to find a suitable account for depreciation expense (e.g., 'Depreciation Expense' or 'Other Expenses')
    const expenseAccountResult = await client.query(
      `SELECT id FROM accounts WHERE name ILIKE 'Depreciation Expense' OR name ILIKE 'Other Expenses' LIMIT 1`
    );
    if (expenseAccountResult.rows.length > 0) {
      defaultExpenseAccountId = expenseAccountResult.rows[0].id;
    } else {
      await client.query('ROLLBACK');
      return res.status(500).json({ error: 'Could not find a suitable expense account for depreciation.' });
    }

    for (const asset of assetsResult.rows) {
      const assetCost = parseFloat(asset.cost);
      const assetSalvageValue = parseFloat(asset.salvage_value || 0);
      const assetUsefulLifeYears = parseInt(asset.useful_life_years, 10);
      const assetDateReceived = new Date(asset.date_received);
      const assetLastDepreciationDate = asset.last_depreciation_date ? new Date(asset.last_depreciation_date) : null;

      // Determine the start date for this depreciation calculation
      // It's either the day after last_depreciation_date, or date_received if no prior depreciation
      let depreciationStartDate = assetLastDepreciationDate
        ? new Date(assetLastDepreciationDate.getFullYear(), assetLastDepreciationDate.getMonth(), assetLastDepreciationDate.getDate() + 1)
        : assetDateReceived;

      // Ensure depreciation doesn't start before the asset was received
      if (depreciationStartDate < assetDateReceived) {
        depreciationStartDate = assetDateReceived;
      }

      // Ensure we don't depreciate beyond the useful life
      const usefulLifeEndDate = new Date(assetDateReceived.getFullYear() + assetUsefulLifeYears, assetDateReceived.getMonth(), assetDateReceived.getDate());
      if (depreciationStartDate >= usefulLifeEndDate) {
          console.log(`Asset ${asset.id} has reached end of useful life or already fully depreciated.`);
          continue; // Skip if already fully depreciated or beyond useful life
      }

      // Adjust calculationEndDate if it's beyond the useful life end date
      let effectiveCalculationEndDate = calculationEndDate;
      if (effectiveCalculationEndDate > usefulLifeEndDate) {
          effectiveCalculationEndDate = usefulLifeEndDate;
      }

      // Calculate depreciation only if the period is valid
      if (depreciationStartDate <= effectiveCalculationEndDate) {
        const depreciationAmount = calculateDepreciation(
          assetCost,
          assetSalvageValue,
          assetUsefulLifeYears,
          depreciationStartDate,
          effectiveCalculationEndDate
        );

        if (depreciationAmount > 0) {
          // 1. Update accumulated_depreciation on the asset
          const newAccumulatedDepreciation = parseFloat(asset.accumulated_depreciation) + depreciationAmount;
          await client.query(
            `UPDATE assets SET accumulated_depreciation = $1, last_depreciation_date = $2 WHERE id = $3`,
            [newAccumulatedDepreciation, effectiveCalculationEndDate.toISOString().split('T')[0], asset.id]
          );

          // 2. Create a transaction for depreciation expense
          const transactionResult = await client.query(
            `INSERT INTO transactions (type, amount, description, date, category, account_id)
             VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
            [
              'expense',
              depreciationAmount,
              `Depreciation Expense for ${asset.name} (ID: ${asset.id})`,
              effectiveCalculationEndDate.toISOString().split('T')[0], // Use end date of calculation period
              'Depreciation Expense', // Use a specific category for depreciation
              defaultExpenseAccountId // Link to a general expense account
            ]
          );
          const transactionId = transactionResult.rows[0].id;

          // 3. Record the depreciation entry
          await client.query(
            `INSERT INTO depreciation_entries (asset_id, depreciation_date, amount, transaction_id)
             VALUES ($1, $2, $3, $4)`,
            [asset.id, effectiveCalculationEndDate.toISOString().split('T')[0], depreciationAmount, transactionId]
          );

          totalDepreciationExpense += depreciationAmount;
          depreciatedAssets.push({ assetId: asset.id, amount: depreciationAmount, transactionId: transactionId });
        }
      }
    }

    await client.query('COMMIT');
    res.json({
      message: 'Depreciation calculated and recorded successfully.',
      totalDepreciationExpense: totalDepreciationExpense,
      depreciatedAssets: depreciatedAssets
    });

  } catch (error: unknown) {
    await client.query('ROLLBACK');
    console.error('Error running depreciation:', error);
    res.status(500).json({ error: 'Failed to run depreciation', detail: error instanceof Error ? error.message : String(error) });
  } finally {
    client.release();
  }
});


/* --- Expenses API --- */
app.get('/expenses', async (req, res) => {
  try {
    // Select all fields relevant for an expense transaction + account_name
    const result = await pool.query(`
      SELECT e.id, e.name, e.details, e.category, e.amount, e.date, e.account_id, acc.name AS account_name
      FROM expenses e
      JOIN accounts acc ON e.account_id = acc.id
      ORDER BY e.date DESC
    `);
    res.json(result.rows);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error fetching expenses:', error);
    res.status(500).json({ error: 'Failed to fetch expenses', detail: error instanceof Error ? error.message : String(error) });
  }
});

app.post('/expenses', async (req, res) => {
  // Ensure all required fields for an expense transaction are captured
  const { name, details, category, amount, date, account_id } = req.body;

  if (!name || amount == null || !date || !account_id) {
    return res.status(400).json({ error: 'Missing required expense fields: name, amount, date, account_id' });
  }

  try {
    const insert = await pool.query(
      `INSERT INTO expenses (name, details, category, amount, date, account_id)
       VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
      // Ensure details and category are correctly handled for nullable columns
      [name, details || null, category || null, amount, date, account_id]
    );
    const insertedId = insert.rows[0].id;

    const fullExpense = await pool.query(`
      SELECT e.id, e.name, e.details, e.category, e.amount, e.date, e.account_id, acc.name AS account_name
      FROM expenses e
      JOIN accounts acc ON e.account_id = acc.id
      WHERE e.id = $1
    `, [insertedId]);

    res.json(fullExpense.rows[0]);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error adding expense:', error);
    res.status(500).json({ error: 'Failed to add expense', detail: error instanceof Error ? error.message : String(error) });
  }
});

// NEW: PUT Update Expense
app.put('/expenses/:id', async (req, res) => {
  const { id } = req.params;
  const { name, details, category, amount, date, account_id } = req.body;

  const updates = [];
  const values = [];
  let paramIndex = 1;

  if (name !== undefined) { updates.push(`name = $${paramIndex++}`); values.push(name); }
  if (details !== undefined) { updates.push(`details = $${paramIndex++}`); values.push(details || null); }
  if (category !== undefined) { updates.push(`category = $${paramIndex++}`); values.push(category || null); }
  if (amount !== undefined) { updates.push(`amount = $${paramIndex++}`); values.push(amount); }
  if (date !== undefined) { updates.push(`date = $${paramIndex++}`); values.push(date); }
  if (account_id !== undefined) { updates.push(`account_id = $${paramIndex++}`); values.push(account_id); }

  if (updates.length === 0) {
    return res.status(400).json({ error: 'No fields provided for update.' });
  }

  values.push(id); // Add ID for WHERE clause

  try {
    const result = await pool.query(
      `UPDATE expenses SET ${updates.join(', ')}, updated_at = CURRENT_TIMESTAMP WHERE id = $${paramIndex} RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Expense not found' });
    }
    // Fetch with account_name for consistent response
    const fullExpense = await pool.query(`
      SELECT e.id, e.name, e.details, e.category, e.amount, e.date, e.account_id, acc.name AS account_name
      FROM expenses e
      JOIN accounts acc ON e.account_id = acc.id
      WHERE e.id = $1
    `, [id]); // Use the ID from params directly

    res.json(fullExpense.rows[0]);
  } catch (error: unknown) {
    console.error('Error updating expense:', error);
    res.status(500).json({ error: 'Failed to update expense', detail: error instanceof Error ? error.message : String(error) });
  }
});

// NEW: DELETE Expense
app.delete('/expenses/:id', async (req, res) => {
  const { id } = req.params;
  try {
    const result = await pool.query('DELETE FROM expenses WHERE id = $1 RETURNING id', [id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Expense not found' });
    }
    res.json({ message: 'Expense deleted successfully' });
  } catch (error: unknown) {
    console.error('Error deleting expense:', error);
    res.status(500).json({ error: 'Failed to delete expense', detail: error instanceof Error ? error.message : String(error) });
  }
});

/* --- File upload & processing --- */
app.post('/transactions/upload', upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ detail: 'No file uploaded' });
  }
  res.json({ message: 'File uploaded and processed (stub)' });
});

/* --- Text description processing (UPDATED to use Gemini API) --- */
app.post('/transactions/process-text', async (req, res) => {
  const { description } = req.body;
  if (!description) {
    return res.status(400).json({ detail: 'Description is required' });
  }

  try {
    // Fetch all existing account names and categories to guide the LLM
    const accountsResult = await pool.query('SELECT name FROM accounts');
    const categoriesResult = await pool.query('SELECT DISTINCT category FROM transactions WHERE category IS NOT NULL');

    const accountNames = accountsResult.rows.map(row => row.name);
    const existingCategories = categoriesResult.rows.map(row => row.category);

    const prompt = `Extract transaction details from the following text.
    
    Text: "${description}"
    
    Rules for extraction:
    - Determine if the transaction is 'income' or 'expense'.
    - Extract the numerical 'amount'.
    - Extract the 'date' in YYYY-MM-DD format. If no year is specified, assume the current year (${new Date().getFullYear()}). If no day or month is specified, assume the current month and day.
    - Assign a relevant 'category' from the following list if applicable, otherwise suggest a new, concise, and appropriate accounting category: ${JSON.stringify(existingCategories)}. Common categories include: 'Sales Revenue', 'Fuel Expense', 'Salaries and Wages Expense', 'Rent Expense', 'Utilities Expense', 'Bank Charges & Fees', 'Interest Income', 'Projects Expenses', 'Accounting Fees Expense', 'Repairs & Maintenance Expense', 'Communication Expense', 'Miscellaneous Expense', 'Owner's Capital'.
    - Provide a concise 'description' of the transaction.
    - Identify the 'account' where the money moved (e.g., 'Bank', 'Cash'). If not explicitly mentioned, assume 'Bank'.
    
    Output the result as a JSON object with the following schema:
    `;

    const payload = {
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: {
          type: "OBJECT",
          properties: {
            type: { type: "STRING", enum: ["income", "expense"] },
            amount: { type: "NUMBER" },
            date: { type: "STRING", format: "date" },
            category: { type: "STRING" },
            description: { type: "STRING" },
            account: { type: "STRING" }
          },
          required: ["type", "amount", "date", "category", "description", "account"]
        }
      }
    };

    const apiKey = ""; // Canvas will provide this at runtime
    const apiUrl = `https://generativelanguage.googleapis.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

    const llmResponse = await fetch(apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const result = await llmResponse.json();

    if (!result.candidates || result.candidates.length === 0 || !result.candidates[0].content || !result.candidates[0].content.parts || result.candidates[0].content.parts.length === 0) {
      throw new Error('LLM response structure is unexpected or content is missing.');
    }

    const extractedData = JSON.parse(result.candidates[0].content.parts[0].text);

    // Look up account_id based on the extracted account name
    const accountLookupResult = await pool.query('SELECT id FROM accounts WHERE name ILIKE $1', [extractedData.account]);
    let account_id: number | null = null;

    if (accountLookupResult.rows.length > 0) {
      account_id = accountLookupResult.rows[0].id;
    } else {
      // If account not found, try to find a default 'Bank' account
      const defaultBankResult = await pool.query('SELECT id FROM accounts WHERE name ILIKE $1 LIMIT 1', ['%bank%']);
      if (defaultBankResult.rows.length > 0) {
        account_id = defaultBankResult.rows[0].id;
      } else {
        // Fallback if no 'Bank' account exists, or handle as an error
        console.warn(`Account '${extractedData.account}' not found, and no default 'Bank' account. Transaction will be returned without account_id.`);
      }
    }

    // Prepare the response for the frontend
    res.json({
      type: extractedData.type,
      amount: extractedData.amount,
      date: extractedData.date,
      category: extractedData.category,
      description: extractedData.description,
      account_id: account_id, // Send the looked-up ID
      account_name: extractedData.account // Send the name for display
    });

  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error processing text with LLM:', error);
    res.status(500).json({ detail: 'Failed to process text description', error: error instanceof Error ? error.message : String(error) });
  }
});

/* --- Audio upload & processing --- */
app.post('/transactions/process-audio', upload.single('audio_file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ detail: 'No audio file uploaded' });
  }

  // In a real application, you would send the audio file to a speech-to-text service
  // and then send the transcribed text to the /transactions/process-text endpoint.
  // For now, we'll just return a stub message.
  res.json({ message: 'Audio uploaded and processed (stub)' });
});
// POST Customer
app.post('/customers', async (req, res) => {
  const { name, contact_person, email, phone, address, tax_id } = req.body;
  if (!name) return res.status(400).json({ error: 'Customer name is required' });

  try {
    const result = await pool.query(
      `INSERT INTO customers (name, contact_person, email, phone, address, tax_id)
       VALUES ($1, $2, $3, $4, $5, $6) RETURNING *`,
      [name, contact_person || null, email || null, phone || null, address || null, tax_id || null]
    );
    res.status(201).json(result.rows[0]);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error adding customer:', error);
    res.status(500).json({ error: 'Failed to add customer', detail: error instanceof Error ? error.message : String(error) });
  }
});
/* --- Customer API Endpoints --- */

// GET All Customers (with optional search filter for the main table)
// This endpoint will be used by CustomerManagement for its main list and search input

app.get('/api/customers', async (req, res) => {
    const searchTerm = req.query.search as string | undefined;

    let query = `
        SELECT
            c.id,
            c.name,
            c.contact_person,
            c.email,
            c.phone,
            c.address,
            c.tax_id,
            COALESCE(SUM(i.total_amount), 0.00) AS total_invoiced /* Calculate total_invoiced */
        FROM
            public.customers c
        LEFT JOIN
            public.invoices i ON c.id = i.customer_id
        WHERE 1=1 /* A trick to easily append conditions */
    `;
    const queryParams: (string | number)[] = [];
    let paramIndex = 1;

    if (searchTerm) {
        query += ` AND (LOWER(c.name) ILIKE $${paramIndex} OR LOWER(c.email) ILIKE $${paramIndex})`;
        queryParams.push(`%${searchTerm.toLowerCase()}%`);
    }

    query += `
        GROUP BY
            c.id, c.name, c.contact_person, c.email, c.phone, c.address, c.tax_id
        ORDER BY
            c.name ASC;
    `;

    try {
        // We use CustomerDB here because the query returns snake_case columns
        const { rows } = await pool.query<CustomerDB>(query, queryParams);
        const formattedRows = rows.map(mapCustomerToFrontend); // Map to frontend camelCase
        res.json(formattedRows);
    } catch (error: unknown) { // Explicitly type error as unknown
        console.error('Error fetching all customers:', error);
        res.status(500).json({ error: 'Failed to fetch customers', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Customers by Search Query (Still useful for specific search-as-you-type components if needed elsewhere)
// This endpoint is less critical for CustomerManagement as the main GET /api/customers handles search.
// You can keep this if other parts of your app specifically rely on it returning only ID and name.
app.get('/api/customers/search', async (req, res) => { // Changed path to /api/customers/search
    const query = req.query.query as string | undefined;
    if (!query) {
        return res.status(400).json({ error: 'Search query is required' });
    }
    const searchTerm = `%${query.toLowerCase()}%`; // Already asserted as string or undefined above

    try {
        const result = await pool.query(
            `SELECT id, name FROM public.customers WHERE LOWER(name) LIKE $1 ORDER BY name`,
            [searchTerm]
        );
        // Note: This returns only id and name, not full CustomerFrontend object
        res.json(result.rows.map(row => ({ id: row.id.toString(), name: row.name })));
    } catch (error: unknown) {
        console.error('Error searching customers:', error);
        res.status(500).json({ error: 'Failed to search customers', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Single Customer by ID
app.get('/api/customers/:id', async (req, res) => { // Changed path to /api/customers/:id
    const { id } = req.params;
    try {
        const result = await pool.query<CustomerDB>('SELECT id, name, contact_person, email, phone, address, tax_id, total_invoiced FROM public.customers WHERE id = $1', [id]);
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Customer not found' });
        }
        res.json(mapCustomerToFrontend(result.rows[0]));
    } catch (error: unknown) {
        console.error('Error fetching customer by ID:', error);
        res.status(500).json({ error: 'Failed to fetch customer', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Create Customer
app.post('/api/customers', async (req, res) => { // Changed path to /api/customers
    const { name, contactPerson, email, phone, address, vatNumber }: CreateUpdateCustomerBody = req.body;

    if (!name) { // Name is NOT NULL in DB
        return res.status(400).json({ error: 'Customer name is required' });
    }

    try {
        const result = await pool.query<CustomerDB>(
            `INSERT INTO public.customers (name, contact_person, email, phone, address, tax_id, total_invoiced)
             VALUES ($1, $2, $3, $4, $5, $6, 0.00) RETURNING id, name, contact_person, email, phone, address, tax_id, total_invoiced`,
            [name, contactPerson || null, email || null, phone || null, address || null, vatNumber || null]
        );
        res.status(201).json(mapCustomerToFrontend(result.rows[0]));
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error adding customer:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') { // Unique violation (e.g., duplicate email)
            return res.status(409).json({ error: 'A customer with this email or VAT number already exists.' });
        }
        res.status(500).json({ error: 'Failed to add customer', detail: error instanceof Error ? error.message : String(error) });
    }
});

// PUT Update Customer
app.put('/api/customers/:id', async (req, res) => { // New endpoint
    const { id } = req.params;
    const { name, contactPerson, email, phone, address, vatNumber }: CreateUpdateCustomerBody = req.body;

    if (!name) { // Name is required for update
        return res.status(400).json({ error: 'Customer name is required for update.' });
    }

    try {
        const result = await pool.query<CustomerDB>(
            `UPDATE public.customers
             SET name = $1, contact_person = $2, email = $3, phone = $4, address = $5, tax_id = $6, updated_at = CURRENT_TIMESTAMP
             WHERE id = $7 RETURNING id, name, contact_person, email, phone, address, tax_id, total_invoiced`,
            [name, contactPerson || null, email || null, phone || null, address || null, vatNumber || null, id]
        );

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Customer not found.' });
        }
        res.json(mapCustomerToFrontend(result.rows[0]));
    } catch (error: unknown) {
        console.error(`Error updating customer with ID ${id}:`, error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'A customer with this email or VAT number already exists.' });
        }
        res.status(500).json({ error: 'Failed to update customer', detail: error instanceof Error ? error.message : String(error) });
    }
});

// DELETE Customer
app.delete('/api/customers/:id', async (req, res) => { // New endpoint
    const { id } = req.params;

    try {
        const { rowCount } = await pool.query(
            'DELETE FROM public.customers WHERE id = $1',
            [id]
        );

        if (rowCount === 0) {
            return res.status(404).json({ error: 'Customer not found.' });
        }
        res.status(204).send(); // No Content for successful deletion
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error(`Error deleting customer with ID ${id}:`, error);
        if (error instanceof Error && 'code' in error && error.code === '23503') { // Foreign key violation (if customer is referenced)
            return res.status(409).json({
                error: 'Cannot delete customer: associated with existing invoices or other records.',
                detail: error.message
            });
        }
        res.status(500).json({ error: 'Failed to delete customer', detail: error instanceof Error ? error.message : String(error) });
    }
});
// GET Vendors
app.get('/vendors', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, name, contact_person, email, phone, address, tax_id FROM vendors ORDER BY name');
    res.json(result.rows);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error fetching vendors:', error);
    res.status(500).json({ error: 'Failed to fetch vendors', detail: error instanceof Error ? error.message : String(error) });
  }
});

// POST Vendor
app.post('/vendors', async (req, res) => {
  const { name, contact_person, email, phone, address, tax_id } = req.body;
  if (!name) return res.status(400).json({ error: 'Vendor name is required' });

  try {
    const result = await pool.query(
      `INSERT INTO vendors (name, contact_person, email, phone, address, tax_id)
       VALUES ($1, $2, $3, $4, $5, $6) RETURNING *`,
      [name, contact_person || null, email || null, phone || null, address || null, tax_id || null]
    );
    res.status(201).json(result.rows[0]);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error adding vendor:', error);
    res.status(500).json({ error: 'Failed to add vendor', detail: error instanceof Error ? error.message : String(error) });
  }
});

// GET Products/Services
app.get('/products-services', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, name, description, unit_price, cost_price, sku, is_service, stock_quantity, unit FROM products_services ORDER BY name'
    );

    // Map the rows to format stock_quantity as an integer
    // and ensure all fields match the ProductDB interface structure
    const formattedRows = result.rows.map(row => ({
      id: row.id,
      name: row.name,
      description: row.description,
      unit_price: Number(row.unit_price), // Ensure unit_price is a number
      cost_price: row.cost_price ? Number(row.cost_price) : null, // Ensure cost_price is a number or null
      sku: row.sku,
      is_service: row.is_service,
      stock_quantity: parseInt(row.stock_quantity, 10), // Convert to integer
      created_at: row.created_at, // Assuming these are handled correctly by pg
      updated_at: row.updated_at,
      tax_rate_id: row.tax_rate_id,
      category: row.category,
      unit: row.unit, // Include the unit
      tax_rate_value: row.tax_rate_value // If this is joined, ensure it's handled
    }));

    res.json(formattedRows);
  } catch (error: unknown) {
    console.error('Error fetching products/services:', error);
    res.status(500).json({ error: 'Failed to fetch products/services', detail: error instanceof Error ? error.message : String(error) });
  }
});

// POST Product/Service
app.post('/products-services', async (req, res) => {
  const { name, description, unit_price, cost_price, sku, is_service, stock_quantity } = req.body;
  if (!name || unit_price == null) {
    return res.status(400).json({ error: 'Product/Service name and unit_price are required' });
  }

  try {
    const result = await pool.query(
      `INSERT INTO products_services (name, description, unit_price, cost_price, sku, is_service, stock_quantity)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [name, description || null, unit_price, cost_price || null, sku || null, is_service || false, stock_quantity || 0]
    );
    res.status(201).json(result.rows[0]);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Error adding product/service:', error);
    res.status(500).json({ error: 'Failed to add product/service', detail: error instanceof Error ? error.message : String(error) });
  }
});

// PUT Update Product Stock
// PUT Update Product Stock
app.put('/api/products-services/:id/stock', async (req, res) => {
  const { id } = req.params; // Product ID
  const { adjustmentQuantity } = req.body; // Quantity to add (positive) or subtract (negative)

  // 1. Explicitly convert adjustmentQuantity to a number
  const parsedAdjustmentQuantity = Number(adjustmentQuantity);

  if (typeof parsedAdjustmentQuantity !== 'number' || isNaN(parsedAdjustmentQuantity)) {
    return res.status(400).json({ error: 'adjustmentQuantity must be a valid number.' });
  }

  try {
    // Start a transaction for atomicity
    await pool.query('BEGIN');

    // 2. Get current stock quantity
    const productResult = await pool.query(
      'SELECT stock_quantity, name FROM public.products_services WHERE id = $1 FOR UPDATE', // FOR UPDATE locks the row
      [id]
    );

    if (productResult.rows.length === 0) {
      await pool.query('ROLLBACK');
      return res.status(404).json({ error: 'Product or service not found.' });
    }

    // 3. Explicitly convert currentStock to a number to prevent string concatenation
    const currentStock = Number(productResult.rows[0].stock_quantity);
    const productName = productResult.rows[0].name;

    // 4. Perform numeric addition
    const newStock = currentStock + parsedAdjustmentQuantity;

    // 5. Check for insufficient stock if selling (adjustmentQuantity is negative)
    if (parsedAdjustmentQuantity < 0 && newStock < 0) {
      await pool.query('ROLLBACK');
      return res.status(400).json({
        error: `Insufficient stock for "${productName}". Current stock: ${currentStock}. Cannot sell ${Math.abs(parsedAdjustmentQuantity)}.`,
        availableStock: currentStock,
      });
    }

    // 6. Update stock quantity
    const updateResult = await pool.query(
      `UPDATE public.products_services
       SET stock_quantity = $1, updated_at = CURRENT_TIMESTAMP
       WHERE id = $2
       RETURNING id, name, stock_quantity`,
      [newStock, id] // newStock is now guaranteed to be a number
    );

    await pool.query('COMMIT');

    res.json({
      message: `Stock for "${updateResult.rows[0].name}" updated successfully.`,
      product: updateResult.rows[0],
    });

  } catch (error: unknown) {
    await pool.query('ROLLBACK'); // Rollback transaction in case of error
    console.error(`Error updating stock for product ID ${id}:`, error);
    res.status(500).json({
      error: 'Failed to update product stock',
      detail: error instanceof Error ? error.message : String(error)
    });
  }
});

// POST Create New Sale
app.post('/api/sales', async (req, res) => {
  const {
    cart,
    paymentType,
    total,
    customer, // This will be selectedCustomer from frontend
    amountPaid,
    change,
    dueDate,
    tellerName, // From frontend (e.g., 'Dummy Teller')
    branch,     // From frontend (e.g., 'Dummy Branch')
    companyName // From frontend (e.g., 'DummyCo')
  } = req.body;

  if (!cart || cart.length === 0 || total === undefined) {
    return res.status(400).json({ error: 'Cart cannot be empty and total amount is required.' });
  }

  const actualAmountPaid = paymentType === 'Cash' ? Number(amountPaid) : null;
  const actualChangeGiven = paymentType === 'Cash' ? Number(change) : null;
  const actualCreditAmount = paymentType === 'Credit' ? Number(total) : null;
  const actualDueDate = paymentType === 'Credit' ? dueDate : null;

  const tellerId = null; // Replace with actual user ID if available from authentication system

  try {
    await pool.query('BEGIN'); // Start a transaction

    // 1. Insert into the sales table
    const salesInsertResult = await pool.query(
      `INSERT INTO public.sales (
        customer_id, customer_name, total_amount, payment_type,
        amount_paid, change_given, credit_amount, due_date,
        teller_id, teller_name, branch, company_name, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, CURRENT_TIMESTAMP)
      RETURNING id, created_at;`,
      [
        customer?.id || null,
        customer?.name || null,
        Number(total),
        paymentType,
        actualAmountPaid,
        actualChangeGiven,
        actualCreditAmount,
        actualDueDate,
        tellerId,
        tellerName,
        branch,
        companyName
      ]
    );

    const saleId = salesInsertResult.rows[0].id;
    const saleTimestamp = salesInsertResult.rows[0].created_at; // Get the timestamp for the transaction date

    // 2. Loop through cart items, deduct stock, and insert into sale_items
    for (const item of cart) {
      const productResult = await pool.query(
        'SELECT stock_quantity, name FROM public.products_services WHERE id = $1 FOR UPDATE',
        [item.id]
      );

      if (productResult.rows.length === 0) {
        await pool.query('ROLLBACK');
        return res.status(404).json({ error: `Product or service with ID ${item.id} not found.` });
      }

      const currentStock = Number(productResult.rows[0].stock_quantity);
      const productName = productResult.rows[0].name;
      const quantityToDeduct = Number(item.quantity);

      const newStock = currentStock - quantityToDeduct;

      if (newStock < 0) {
        await pool.query('ROLLBACK');
        return res.status(400).json({
          error: `Insufficient stock for "${productName}". Current stock: ${currentStock}. Cannot sell ${quantityToDeduct}.`,
          availableStock: currentStock,
        });
      }

      await pool.query(
        `UPDATE public.products_services
         SET stock_quantity = $1, updated_at = CURRENT_TIMESTAMP
         WHERE id = $2;`,
        [newStock, item.id]
      );

      await pool.query(
        `INSERT INTO public.sale_items (
          sale_id, product_id, product_name, quantity, unit_price_at_sale, subtotal
        ) VALUES ($1, $2, $3, $4, $5, $6);`,
        [
          saleId,
          item.id,
          item.name,
          Number(item.quantity),
          Number(item.unit_price),
          Number(item.subtotal)
        ]
      );
    }

    // --- NEW: Insert into the public.transactions table for Sales Revenue ---
    const salesRevenueAccountId = 5; // As specified: Sales Revenue Account ID is 5
    const transactionType = 'Sales Revenue';
    const transactionDescription = `POS Sale ID: ${saleId}`;
    const transactionCategory = 'Revenue'; // Or 'Sales' as per your preference
    const transactionDate = new Date(saleTimestamp).toISOString().split('T')[0]; // Format as YYYY-MM-DD

    await pool.query(
      `INSERT INTO public.transactions (
        type, amount, description, date, category, account_id, source, confirmed, firebase_uid
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9);`,
      [
        transactionType,
        Number(total),
        transactionDescription,
        transactionDate,
        transactionCategory,
        salesRevenueAccountId,
        'POS', // Source can be 'POS'
        true, // Confirmed
        null // firebase_uid - assuming not used here, or use tellerId if it becomes a UUID
      ]
    );

    await pool.query('COMMIT'); // Commit the transaction if all successful

    res.status(201).json({
      message: 'Sale submitted successfully and transaction recorded!',
      saleId: saleId,
      timestamp: saleTimestamp,
    });

  } catch (error: unknown) {
    await pool.query('ROLLBACK'); // Rollback transaction in case of error
    console.error('Error submitting sale:', error);
    res.status(500).json({
      error: 'Failed to submit sale',
      detail: error instanceof Error ? error.message : String(error)
    });
  }
});

/* --- Invoice API Endpoints --- */

// GET All Invoices (List View)
app.get('/api/invoices', async (req, res) => {
    try {
        const result = await pool.query(`
            SELECT
                i.id,
                i.invoice_number,
                i.invoice_date,
                i.due_date,
                i.total_amount,
                i.status,
                i.currency,
                c.name AS customer_name,
                c.id AS customer_id
            FROM public.invoices i
            LEFT JOIN public.customers c ON i.customer_id = c.id -- Changed to LEFT JOIN
            ORDER BY i.invoice_date DESC, i.invoice_number DESC
        `);
        res.json(result.rows);
    } catch (error: unknown) {
        console.error('Error fetching invoices:', error);
        res.status(500).json({ error: 'Failed to fetch invoices', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Single Invoice with Line Items
// GET Single Invoice with Line Items
app.get('/api/invoices/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const invoiceResult = await pool.query(`
            SELECT
                i.id,
                i.invoice_number,
                i.customer_id,
                c.name AS customer_name,
                c.email AS customer_email,
                c.phone AS customer_phone,
                c.address AS customer_address,
                i.invoice_date,
                i.due_date,
                i.total_amount,
                i.status,
                i.currency,
                i.notes,
                i.created_at,
                i.updated_at
            FROM public.invoices i
            LEFT JOIN public.customers c ON i.customer_id = c.id -- Changed to LEFT JOIN
            WHERE i.id = $1
        `, [id]);

        if (invoiceResult.rows.length === 0) {
            return res.status(404).json({ error: 'Invoice not found' });
        }

        // --- THIS PART WAS MISSING AND CAUSED THE ERROR ---
        const lineItemsResult = await pool.query(`
            SELECT
                ili.id,
                ili.product_service_id,
                ps.name AS product_service_name,
                ili.description,
                ili.quantity,
                ili.unit_price,
                ili.line_total,
                ili.tax_rate
            FROM public.invoice_line_items ili
            LEFT JOIN public.products_services ps ON ili.product_service_id = ps.id
            WHERE ili.invoice_id = $1
            ORDER BY ili.id
        `, [id]);
        // --- END OF MISSING PART ---

        const invoice = invoiceResult.rows[0];
        invoice.line_items = lineItemsResult.rows;

        res.json(invoice);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching invoice:', error);
        res.status(500).json({ error: 'Failed to fetch invoice', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Create Invoice
app.post('/api/invoices', async (req, res) => { // Changed path to /api/invoices
    const { invoice_number, customer_id, customer_name, invoice_date, due_date, total_amount, status, currency, notes, line_items } = req.body;

    if (!invoice_number || !invoice_date || !due_date || total_amount == null || !line_items || line_items.length === 0) {
        return res.status(400).json({ error: 'Missing required invoice fields or line items' });
    }

    if (!customer_id && (!customer_name || customer_name.trim() === '')) {
        return res.status(400).json({ error: 'Customer ID or Customer Name is required.' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        let finalCustomerId = customer_id;

        if (!finalCustomerId) {
            const existingCustomerResult = await client.query('SELECT id FROM public.customers WHERE LOWER(name) = LOWER($1)', [customer_name.trim()]);

            if (existingCustomerResult.rows.length > 0) {
                finalCustomerId = existingCustomerResult.rows[0].id;
            } else {
                const newCustomerResult = await client.query(
                    `INSERT INTO public.customers (name, total_invoiced) VALUES ($1, 0.00) RETURNING id`,
                    [customer_name.trim()]
                );
                finalCustomerId = newCustomerResult.rows[0].id;
            }
        }

        const invoiceResult = await client.query(
            `INSERT INTO public.invoices (invoice_number, customer_id, invoice_date, due_date, total_amount, status, currency, notes)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id`,
            [invoice_number, finalCustomerId, invoice_date, due_date, total_amount, status || 'Draft', currency || 'ZAR', notes || null]
        );
        const invoiceId = invoiceResult.rows[0].id;

        for (const item of line_items) {
            if (!item.description || item.quantity == null || item.unit_price == null || item.line_total == null) {
                throw new Error('Missing required line item fields');
            }
            await client.query(
                `INSERT INTO public.invoice_line_items (invoice_id, product_service_id, description, quantity, unit_price, line_total, tax_rate)
                 VALUES ($1, $2, $3, $4, $5, $6, $7)`,
                [invoiceId, item.product_service_id || null, item.description, item.quantity, item.unit_price, item.line_total, item.tax_rate || 0.00]
            );
        }

        await client.query('COMMIT');
        res.status(201).json({ id: invoiceId, message: 'Invoice created successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error creating invoice:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'Invoice number already exists.' });
        }
        res.status(500).json({ error: 'Failed to create invoice', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// PUT Update Invoice
app.put('/api/invoices/:id', async (req, res) => { // Changed path to /api/invoices/:id
    const { id } = req.params;
    const { invoice_number, customer_id, customer_name, invoice_date, due_date, total_amount, status, currency, notes, line_items } = req.body;

    if (!invoice_number || !invoice_date || !due_date || total_amount == null || !line_items) {
        return res.status(400).json({ error: 'Missing required invoice fields or line items' });
    }

    if (!customer_id && (!customer_name || customer_name.trim() === '')) {
        return res.status(400).json({ error: 'Customer ID or Customer Name is required.' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        let finalCustomerId = customer_id;

        if (!finalCustomerId) {
            const existingCustomerResult = await client.query('SELECT id FROM public.customers WHERE LOWER(name) = LOWER($1)', [customer_name.trim()]);

            if (existingCustomerResult.rows.length > 0) {
                finalCustomerId = existingCustomerResult.rows[0].id;
            } else {
                const newCustomerResult = await client.query(
                    `INSERT INTO public.customers (name, total_invoiced) VALUES ($1, 0.00) RETURNING id`,
                    [customer_name.trim()]
                );
                finalCustomerId = newCustomerResult.rows[0].id;
            }
        }

        const updateInvoiceResult = await client.query(
            `UPDATE public.invoices
             SET
               invoice_number = $1,
               customer_id = $2,
               invoice_date = $3,
               due_date = $4,
               total_amount = $5,
               status = $6,
               currency = $7,
               notes = $8,
               updated_at = CURRENT_TIMESTAMP
             WHERE id = $9 RETURNING id`,
            [invoice_number, finalCustomerId, invoice_date, due_date, total_amount, status, currency || 'ZAR', notes || null, id]
        );

        if (updateInvoiceResult.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Invoice not found for update' });
        }

        await client.query('DELETE FROM public.invoice_line_items WHERE invoice_id = $1', [id]);

        for (const item of line_items) {
            if (!item.description || item.quantity == null || item.unit_price == null || item.line_total == null) {
                throw new Error('Missing required line item fields');
            }
            await client.query(
                `INSERT INTO public.invoice_line_items (invoice_id, product_service_id, description, quantity, unit_price, line_total, tax_rate)
                 VALUES ($1, $2, $3, $4, $5, $6, $7)`,
                [id, item.product_service_id || null, item.description, item.quantity, item.unit_price, item.line_total, item.tax_rate || 0.00]
            );
        }

        await client.query('COMMIT');
        res.json({ id: id, message: 'Invoice updated successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error updating invoice:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'Invoice number already exists.' });
        }
        res.status(500).json({ error: 'Failed to update invoice', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// DELETE Invoice
app.delete('/api/invoices/:id', async (req, res) => { // Changed path to /api/invoices/:id
    const { id } = req.params;
    try {
        const result = await pool.query('DELETE FROM public.invoices WHERE id = $1 RETURNING id', [id]);
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Invoice not found' });
        }
        res.json({ message: 'Invoice deleted successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error deleting invoice:', error);
        res.status(500).json({ error: 'Failed to delete invoice', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Record Invoice Payment
app.post('/api/invoices/:id/payment', async (req, res) => { // Changed path to /api/invoices/:id/payment
    const { id } = req.params; // Invoice ID
    const { amount_paid, payment_date, notes, account_id, transaction_description, transaction_category } = req.body;

    if (amount_paid == null || !payment_date || !account_id) {
        return res.status(400).json({ error: 'Amount paid, payment date, and account ID are required' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        const transactionResult = await pool.query(
            `INSERT INTO public.transactions (type, amount, description, date, category, account_id)
             VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
            ['income', amount_paid, transaction_description || `Payment for Invoice ${id}`, payment_date, transaction_category || 'Trading Income', account_id]
        );
        const transactionId = transactionResult.rows[0].id;

        await client.query(
            `INSERT INTO public.invoice_payments (invoice_id, transaction_id, amount_paid, payment_date, notes)
             VALUES ($1, $2, $3, $4, $5)`,
            [id, transactionId, amount_paid, payment_date, notes || null]
        );

        await client.query('COMMIT');
        res.status(201).json({ message: 'Invoice payment recorded successfully', transaction_id: transactionId });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error recording invoice payment:', error);
        res.status(500).json({ error: 'Failed to record invoice payment', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

/* --- Quotations API Endpoints --- */

// GET All Quotations (List View)
app.get('/api/quotations', async (req, res) => { // Changed path to /api/quotations
    try {
        const result = await pool.query(`
            SELECT
                q.id,
                q.quotation_number,
                q.quotation_date,
                q.expiry_date,
                q.total_amount,
                q.status,
                q.currency,
                c.name AS customer_name,
                c.id AS customer_id
            FROM public.quotations q
            JOIN public.customers c ON q.customer_id = c.id
            ORDER BY q.quotation_date DESC, q.quotation_number DESC
        `);
        res.json(result.rows);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching quotations:', error);
        res.status(500).json({ error: 'Failed to fetch quotations', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Single Quotation with Line Items
app.get('/api/quotations/:id', async (req, res) => { // Changed path to /api/quotations/:id
    const { id } = req.params;
    try {
        const quotationResult = await pool.query(`
            SELECT
                q.id,
                q.quotation_number,
                q.customer_id,
                c.name AS customer_name,
                c.email AS customer_email,
                c.phone AS customer_phone,
                c.address AS customer_address,
                q.quotation_date,
                q.expiry_date,
                q.total_amount,
                q.status,
                q.currency,
                q.notes,
                q.created_at,
                q.updated_at
            FROM public.quotations q
            JOIN public.customers c ON q.customer_id = c.id
            WHERE q.id = $1
        `, [id]);

        if (quotationResult.rows.length === 0) {
            return res.status(404).json({ error: 'Quotation not found' });
        }

        const lineItemsResult = await pool.query(`
            SELECT
                qli.id,
                qli.product_service_id,
                ps.name AS product_service_name,
                qli.description,
                qli.quantity,
                qli.unit_price,
                qli.line_total,
                qli.tax_rate
            FROM public.quotation_line_items qli
            LEFT JOIN public.products_services ps ON qli.product_service_id = ps.id
            WHERE qli.quotation_id = $1
            ORDER BY qli.id
        `, [id]);

        const quotation = quotationResult.rows[0];
        quotation.line_items = lineItemsResult.rows;

        res.json(quotation);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching quotation:', error);
        res.status(500).json({ error: 'Failed to fetch quotation', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Create Quotation
app.post('/api/quotations', async (req, res) => { // Changed path to /api/quotations
    const { quotation_number, customer_id, customer_name, quotation_date, expiry_date, total_amount, status, currency, notes, line_items } = req.body;

    if (!quotation_number || !quotation_date || total_amount == null || !line_items || line_items.length === 0) {
        return res.status(400).json({ error: 'Missing required quotation fields or line items' });
    }

    // Validate customer: either customer_id or customer_name must be present
    if (!customer_id && (!customer_name || customer_name.trim() === '')) {
        return res.status(400).json({ error: 'Customer ID or Customer Name is required.' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        let finalCustomerId = customer_id;

        // If customer_id is NOT provided, it means we need to create a new customer
        if (!finalCustomerId) {
            // Check if a customer with this name already exists to prevent duplicates
            const existingCustomerResult = await client.query('SELECT id FROM public.customers WHERE LOWER(name) = LOWER($1)', [customer_name.trim()]);

            if (existingCustomerResult.rows.length > 0) {
                // If customer exists, use their ID
                finalCustomerId = existingCustomerResult.rows[0].id;
            } else {
                // Otherwise, create a new customer
                const newCustomerResult = await client.query(
                    `INSERT INTO public.customers (name, total_invoiced) VALUES ($1, 0.00) RETURNING id`,
                    [customer_name.trim()]
                );
                finalCustomerId = newCustomerResult.rows[0].id;
            }
        }

        const quotationResult = await client.query(
            `INSERT INTO public.quotations (quotation_number, customer_id, quotation_date, expiry_date, total_amount, status, currency, notes)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id`,
            [quotation_number, finalCustomerId, quotation_date, expiry_date || null, total_amount, status || 'Draft', currency || 'ZAR', notes || null]
        );
        const quotationId = quotationResult.rows[0].id;

        for (const item of line_items) {
            if (!item.description || item.quantity == null || item.unit_price == null || item.line_total == null) {
                throw new Error('Missing required line item fields');
            }
            await client.query(
                `INSERT INTO public.quotation_line_items (quotation_id, product_service_id, description, quantity, unit_price, line_total, tax_rate)
                 VALUES ($1, $2, $3, $4, $5, $6, $7)`,
                [quotationId, item.product_service_id || null, item.description, item.quantity, item.unit_price, item.line_total, item.tax_rate || 0.00]
            );
        }

        await client.query('COMMIT');
        res.status(201).json({ id: quotationId, message: 'Quotation created successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error creating quotation:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'Quotation number already exists.' });
        }
        res.status(500).json({ error: 'Failed to create quotation', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// PUT Update Quotation
app.put('/api/quotations/:id', async (req, res) => { // Changed path to /api/quotations/:id
    const { id } = req.params; // Correctly extract 'id' from params
    const { quotation_number, customer_id, customer_name, quotation_date, expiry_date, total_amount, status, currency, notes, line_items } = req.body;

    if (!quotation_number || !quotation_date || total_amount == null || !line_items) {
        return res.status(400).json({ error: 'Missing required quotation fields or line items' });
    }

    // Validate customer: either customer_id or customer_name must be present
    if (!customer_id && (!customer_name || customer_name.trim() === '')) {
        return res.status(400).json({ error: 'Customer ID or Customer Name is required.' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        let finalCustomerId = customer_id;

        if (!finalCustomerId) {
            const existingCustomerResult = await client.query('SELECT id FROM public.customers WHERE LOWER(name) = LOWER($1)', [customer_name.trim()]);

            if (existingCustomerResult.rows.length > 0) {
                finalCustomerId = existingCustomerResult.rows[0].id;
            } else {
                const newCustomerResult = await client.query(
                    `INSERT INTO public.customers (name, total_invoiced) VALUES ($1, 0.00) RETURNING id`,
                    [customer_name.trim()]
                );
                finalCustomerId = newCustomerResult.rows[0].id;
            }
        }

        const updateQuotationResult = await client.query(
            `UPDATE public.quotations
             SET
               quotation_number = $1,
               customer_id = $2,
               quotation_date = $3,
               expiry_date = $4,
               total_amount = $5,
               status = $6,
               currency = $7,
               notes = $8,
               updated_at = CURRENT_TIMESTAMP
             WHERE id = $9 RETURNING id`,
            [quotation_number, finalCustomerId, quotation_date, expiry_date || null, total_amount, status, currency || 'ZAR', notes || null, id]
        );

        if (updateQuotationResult.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Quotation not found for update' });
        }

        await client.query('DELETE FROM public.quotation_line_items WHERE quotation_id = $1', [id]);

        for (const item of line_items) {
            if (!item.description || item.quantity == null || item.unit_price == null || item.line_total == null) {
                throw new Error('Missing required line item fields');
            }
            await client.query(
                `INSERT INTO public.quotation_line_items (quotation_id, product_service_id, description, quantity, unit_price, line_total, tax_rate)
                 VALUES ($1, $2, $3, $4, $5, $6, $7)`,
                [id, item.product_service_id || null, item.description, item.quantity, item.unit_price, item.line_total, item.tax_rate || 0.00] // Use 'id' here
            );
        }

        await client.query('COMMIT');
        res.json({ id: id, message: 'Quotation updated successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error updating quotation:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'Quotation number already exists.' });
        }
        res.status(500).json({ error: 'Failed to update quotation', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// DELETE Quotation
app.delete('/api/quotations/:id', async (req, res) => { // Changed path to /api/quotations/:id
    const { id } = req.params;
    try {
        const result = await pool.query('DELETE FROM public.quotations WHERE id = $1 RETURNING id', [id]);
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Quotation not found' });
        }
        res.json({ message: 'Quotation deleted successfully' });
    }
    catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error deleting quotation:', error);
        res.status(500).json({ error: 'Failed to delete quotation', detail: error instanceof Error ? error.message : String(error) });
    }
});


/* --- Purchases API Endpoints --- */

// GET All Purchases (List View)
app.get('/api/purchases', async (req, res) => { // Changed path to /api/purchases
    try {
        const result = await pool.query(`
            SELECT
                p.id,
                p.po_number,
                p.order_date,
                p.delivery_date,
                p.total_amount,
                p.status,
                p.currency,
                v.name AS vendor_name,
                v.id AS vendor_id
            FROM public.purchases p
            JOIN public.vendors v ON p.vendor_id = v.id
            ORDER BY p.order_date DESC, p.po_number DESC
        `);
        res.json(result.rows);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching purchases:', error);
        res.status(500).json({ error: 'Failed to fetch purchases', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Single Purchase with Line Items
app.get('/api/purchases/:id', async (req, res) => { // Changed path to /api/purchases/:id
    const { id } = req.params;
    try {
        const purchaseResult = await pool.query(`
            SELECT
                p.id,
                p.po_number,
                p.vendor_id,
                v.name AS vendor_name,
                v.email AS vendor_email,
                v.phone AS vendor_phone,
                v.address AS vendor_address,
                p.order_date,
                p.delivery_date,
                p.total_amount,
                p.status,
                p.currency,
                p.notes,
                p.created_at,
                p.updated_at
            FROM public.purchases p
            JOIN public.vendors v ON p.vendor_id = v.id
            WHERE p.id = $1
        `, [id]);

        if (purchaseResult.rows.length === 0) {
            return res.status(404).json({ error: 'Purchase not found' });
        }

        const lineItemsResult = await pool.query(`
            SELECT
                pli.id,
                pli.product_service_id,
                ps.name AS product_service_name,
                pli.description,
                pli.quantity,
                pli.unit_cost,
                pli.line_total,
                pli.tax_rate
            FROM public.purchase_line_items pli
            LEFT JOIN public.products_services ps ON pli.product_service_id = ps.id
            WHERE pli.purchase_id = $1
            ORDER BY pli.id
        `, [id]);

        const purchase = purchaseResult.rows[0];
        purchase.line_items = lineItemsResult.rows;

        res.json(purchase);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching purchase:', error);
        res.status(500).json({ error: 'Failed to fetch purchase', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Create Purchase
app.post('/api/purchases', async (req, res) => { // Changed path to /api/purchases
    // Destructure vendor_name (manual input) from req.body
    const { po_number, vendor_id, vendor_name, order_date, delivery_date, total_amount, status, currency, notes, line_items } = req.body;

    if (!order_date || total_amount == null || !line_items || line_items.length === 0) {
        return res.status(400).json({ error: 'Missing required purchase fields or line items' });
    }

    // Validate vendor: either vendor_id or vendor_name must be present
    if (!vendor_id && (!vendor_name || vendor_name.trim() === '')) {
        return res.status(400).json({ error: 'Vendor ID or Vendor Name is required.' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        let finalVendorId = vendor_id;

        // If vendor_id is NOT provided, it means we need to create a new vendor
        if (!finalVendorId) {
            // Check if a vendor with this name already exists to prevent duplicates
            const existingVendorResult = await pool.query('SELECT id FROM public.vendors WHERE LOWER(name) = LOWER($1)', [vendor_name.trim()]);

            if (existingVendorResult.rows.length > 0) {
                // If vendor exists, use their ID
                finalVendorId = existingVendorResult.rows[0].id;
            } else {
                // Otherwise, create a new vendor
                const newVendorResult = await pool.query(
                    `INSERT INTO public.vendors (name) VALUES ($1) RETURNING id`, // Assuming vendors table has 'name'
                    [vendor_name.trim()]
                );
                finalVendorId = newVendorResult.rows[0].id;
            }
        }

        const purchaseResult = await pool.query(
            `INSERT INTO public.purchases (po_number, vendor_id, order_date, delivery_date, total_amount, status, currency, notes)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id`,
            [po_number || null, finalVendorId, order_date, delivery_date || null, total_amount, status || 'Draft', currency || 'ZAR', notes || null]
        );
        const purchaseId = purchaseResult.rows[0].id;

        for (const item of line_items) {
            if (!item.description || item.quantity == null || item.unit_cost == null || item.line_total == null) {
                throw new Error('Missing required line item fields');
            }
            await pool.query(
                `INSERT INTO public.purchase_line_items (purchase_id, product_service_id, description, quantity, unit_cost, line_total, tax_rate)
                 VALUES ($1, $2, $3, $4, $5, $6, $7)`,
                [purchaseId, item.product_service_id || null, item.description, item.quantity, item.unit_cost, item.line_total, item.tax_rate || 0.00]
            );
        }

        await client.query('COMMIT');
        res.status(201).json({ id: purchaseId, message: 'Purchase created successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error creating purchase:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'Purchase order number already exists.' });
        }
        res.status(500).json({ error: 'Failed to create purchase', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// PUT Update Purchase
app.put('/api/purchases/:id', async (req, res) => { // Changed path to /api/purchases/:id
    const { id } = req.params;
    const { po_number, vendor_id, vendor_name, order_date, delivery_date, total_amount, status, currency, notes, line_items } = req.body;

    if (!order_date || total_amount == null || !line_items) {
        return res.status(400).json({ error: 'Missing required purchase fields or line items' });
    }

    // Validate vendor: either vendor_id or vendor_name must be present
    if (!vendor_id && (!vendor_name || vendor_name.trim() === '')) {
        return res.status(400).json({ error: 'Vendor ID or Vendor Name is required.' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        let finalVendorId = vendor_id;

        if (!finalVendorId) {
            const existingVendorResult = await pool.query('SELECT id FROM public.vendors WHERE LOWER(name) = LOWER($1)', [vendor_name.trim()]);

            if (existingVendorResult.rows.length > 0) {
                finalVendorId = existingVendorResult.rows[0].id;
            } else {
                const newVendorResult = await pool.query(
                    `INSERT INTO public.vendors (name) VALUES ($1) RETURNING id`,
                    [vendor_name.trim()]
                );
                finalVendorId = newVendorResult.rows[0].id;
            }
        }

        const updatePurchaseResult = await pool.query(
            `UPDATE public.purchases
             SET
               po_number = $1,
               vendor_id = $2,
               order_date = $3,
               delivery_date = $4,
               total_amount = $5,
               status = $6,
               currency = $7,
               notes = $8,
               updated_at = CURRENT_TIMESTAMP
             WHERE id = $9 RETURNING id`,
            [po_number || null, finalVendorId, order_date, delivery_date || null, total_amount, status, currency || 'ZAR', notes || null, id]
        );

        if (updatePurchaseResult.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Purchase not found for update' });
        }

        await client.query('DELETE FROM public.purchase_line_items WHERE purchase_id = $1', [id]);

        for (const item of line_items) {
            if (!item.description || item.quantity == null || item.unit_cost == null || item.line_total == null) {
                throw new Error('Missing required line item fields');
            }
            await client.query(
                `INSERT INTO public.purchase_line_items (purchase_id, product_service_id, description, quantity, unit_cost, line_total, tax_rate)
                 VALUES ($1, $2, $3, $4, $5, $6, $7)`,
                [id, item.product_service_id || null, item.description, item.quantity, item.unit_cost, item.line_total, item.tax_rate || 0.00]
            );
        }

        await client.query('COMMIT');
        res.json({ id: id, message: 'Purchase updated successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error updating purchase:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'Purchase order number already exists.' });
        }
        res.status(500).json({ error: 'Failed to update purchase', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// DELETE Purchase
app.delete('/api/purchases/:id', async (req, res) => { // Changed path to /api/purchases/:id
    const { id } = req.params;
    try {
        const result = await pool.query('DELETE FROM public.purchases WHERE id = $1 RETURNING id', [id]);
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Purchase not found' });
        }
        res.json({ message: 'Purchase deleted successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error deleting purchase:', error);
        res.status(500).json({ error: 'Failed to delete purchase', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Record Purchase Payment
app.post('/api/purchases/:id/payment', async (req, res) => { // Changed path to /api/purchases/:id/payment
    const { id } = req.params; // Purchase ID
    const { amount_paid, payment_date, notes, account_id, transaction_description, transaction_category } = req.body;

    if (amount_paid == null || !payment_date || !account_id) {
        return res.status(400).json({ error: 'Amount paid, payment date, and account ID are required' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        // 1. Create a transaction entry
        const transactionResult = await pool.query(
            `INSERT INTO public.transactions (type, amount, description, date, category, account_id)
             VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
            ['expense', amount_paid, transaction_description || `Payment for Purchase ${id}`, payment_date, transaction_category || 'Business Expenses', account_id]
        );
        const transactionId = transactionResult.rows[0].id;

        // 2. Create a purchase payment entry
        await client.query(
            `INSERT INTO public.purchase_payments (purchase_id, transaction_id, amount_paid, payment_date, notes)
             VALUES ($1, $2, $3, $4, $5)`,
            [id, transactionId, amount_paid, payment_date, notes || null]
        );

        // Optional: Update purchase status if fully paid (requires more logic)

        await client.query('COMMIT');
        res.status(201).json({ message: 'Purchase payment recorded successfully', transaction_id: transactionId });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error recording purchase payment:', error);
        res.status(500).json({ error: 'Failed to record purchase payment', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

/* --- EMPLOYEES API (Existing, with slight modifications for clarity) --- */

// GET All Employees (List View) - No change needed here for the status column, but ensure it fetches all relevant employee data
app.get('/employees', async (req, res) => {
    try {
        const result = await pool.query(`
            SELECT
                e.id,
                e.name,
                e.position,
                e.email,
                e.id_number, /* Added id_number here for consistency */
                e.phone,
                e.start_date,
                e.payment_type,
                e.base_salary,
                e.hourly_rate,
                /* Sum of approved hours for each employee for dashboard stats */
                COALESCE((SELECT SUM(hours_worked) FROM time_entries WHERE employee_id = e.id AND status = 'approved'), 0) AS hours_worked_total,
                bd.account_holder, /* Include account_holder for frontend Employee type */
                bd.bank_name,
                bd.account_number,
                bd.branch_code
            FROM employees e
            LEFT JOIN bank_details bd ON e.id = bd.employee_id
            ORDER BY e.name ASC
        `);
        res.json(result.rows);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching employees:', error);
        res.status(500).json({ error: 'Failed to fetch employees', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Single Employee with Bank Details and total hours worked - No change needed, already good
app.get('/employees/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const employeeResult = await pool.query(`
            SELECT
                e.id,
                e.name,
                e.position,
                e.email,
                e.id_number,
                e.phone,
                e.start_date,
                e.payment_type,
                e.base_salary,
                e.hourly_rate,
                bd.account_holder,
                bd.bank_name,
                bd.account_number,
                bd.branch_code,
                e.created_at,
                e.updated_at
            FROM employees e
            LEFT JOIN bank_details bd ON e.id = bd.employee_id
            WHERE e.id = $1
        `, [id]);

        if (employeeResult.rows.length === 0) {
            return res.status(404).json({ error: 'Employee not found' });
        }

        const employee = employeeResult.rows[0];

        // Fetch total hours worked for this employee
        const totalHoursResult = await pool.query(`
            SELECT COALESCE(SUM(hours_worked), 0) AS total_hours
            FROM time_entries
            WHERE employee_id = $1 AND status = 'approved' /* Only sum approved hours */
        `, [id]);

        employee.hours_worked_total = parseFloat(totalHoursResult.rows[0].total_hours);

        // Nested bankDetails object for frontend consistency
        if (employee.account_holder || employee.bank_name || employee.account_number || employee.branch_code) {
            employee.bankDetails = {
                account_holder: employee.account_holder,
                bank_name: employee.bank_name,
                account_number: employee.account_number,
                branch_code: employee.branch_code
            };
        } else {
            employee.bankDetails = null; // Or undefined, depending on frontend preference
        }
        // Clean up flat bank details if you only want nested
        delete employee.account_holder;
        delete employee.bank_name;
        delete employee.account_number;
        delete employee.branch_code;


        res.json(employee);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching employee:', error);
        res.status(500).json({ error: 'Failed to fetch employee', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Create New Employee (with optional bank details) - No change needed
app.post('/employees', async (req, res) => {
    const {
        name, position, email, idNumber, phone, startDate,
        paymentType, baseSalary, hourlyRate,
        bankDetails // Object: { accountHolder, bankName, accountNumber, branchCode }
    } = req.body;

    // Basic validation
    if (!name || !email || !idNumber || !startDate || !paymentType) {
        return res.status(400).json({ error: 'Missing required employee fields.' });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        // Insert into employees table
        const employeeResult = await pool.query(
            `INSERT INTO employees (name, position, email, id_number, phone, start_date, payment_type, base_salary, hourly_rate)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id`,
            [name, position || null, email, idNumber, phone || null, startDate, paymentType, baseSalary || null, hourlyRate || null]
        );
        const employeeId = employeeResult.rows[0].id;

        // If bank details are provided, insert into bank_details table
        if (bankDetails && bankDetails.accountHolder && bankDetails.bankName && bankDetails.accountNumber) {
            await client.query(
                `INSERT INTO bank_details (employee_id, account_holder, bank_name, account_number, branch_code)
                 VALUES ($1, $2, $3, $4, $5)`,
                [employeeId, bankDetails.accountHolder, bankDetails.bankName, bankDetails.accountNumber, bankDetails.branchCode || null]
            );
        }

        await client.query('COMMIT');
        res.status(201).json({ id: employeeId, message: 'Employee created successfully' });
    }
    catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error creating employee:', error);
        res.status(500).json({ error: 'Failed to create employee', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// PUT Update Employee Details (including bank details and hours_worked_total)
app.put('/employees/:id', async (req, res) => {
    const { id } = req.params;
    const {
        name, position, email, idNumber, phone, startDate,
        paymentType, baseSalary, hourlyRate, hoursWorked, /* Added hoursWorked */
        bankDetails // Object: { accountHolder, bankName, accountNumber, branchCode }
    } = req.body;

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        // Build dynamic UPDATE query for employees table
        const employeeUpdates = [];
        const employeeValues = [];
        let empParamIndex = 1;

        if (name !== undefined) { employeeUpdates.push(`name = $${empParamIndex++}`); employeeValues.push(name); }
        if (position !== undefined) { employeeUpdates.push(`position = $${empParamIndex++}`); employeeValues.push(position || null); }
        if (email !== undefined) { employeeUpdates.push(`email = $${empParamIndex++}`); employeeValues.push(email); }
        if (idNumber !== undefined) { employeeUpdates.push(`id_number = $${empParamIndex++}`); employeeValues.push(idNumber); }
        if (phone !== undefined) { employeeUpdates.push(`phone = $${empParamIndex++}`); employeeValues.push(phone || null); }
        if (startDate !== undefined) { employeeUpdates.push(`start_date = $${empParamIndex++}`); employeeValues.push(startDate); }
        if (paymentType !== undefined) { employeeUpdates.push(`payment_type = $${empParamIndex++}`); employeeValues.push(paymentType); }
        if (baseSalary !== undefined) { employeeUpdates.push(`base_salary = $${empParamIndex++}`); employeeValues.push(baseSalary || null); }
        if (hourlyRate !== undefined) { employeeUpdates.push(`hourly_rate = $${empParamIndex++}`); employeeValues.push(hourlyRate || null); }
        // Only update hours_worked_total if it's explicitly provided (e.g., from time entry approval)
        if (hoursWorked !== undefined) {
            // CRITICAL FIX: Ensure hoursWorked is a valid number before using it in SQL
            const parsedHoursWorked = parseFloat(hoursWorked);
            if (isNaN(parsedHoursWorked)) {
                throw new Error('Invalid numeric value for hoursWorked.');
            }
            employeeUpdates.push(`hours_worked_total = $${empParamIndex++}`);
            employeeValues.push(parsedHoursWorked);
        }

        employeeUpdates.push(`updated_at = CURRENT_TIMESTAMP`);
        employeeValues.push(id); // The ID is the last parameter for WHERE clause

        if (employeeUpdates.length > 1) { // More than just updated_at
            const employeeUpdateResult = await pool.query(
                `UPDATE employees
                 SET ${employeeUpdates.join(', ')}
                 WHERE id = $${empParamIndex} RETURNING id`,
                employeeValues
            );

            if (employeeUpdateResult.rows.length === 0) {
                await client.query('ROLLBACK');
                return res.status(404).json({ error: 'Employee not found for update' });
            }
        }

        // Handle bank details: upsert (update or insert if not exists)
        if (bankDetails) {
            // Check if bank details already exist for this employee
            const existingBankDetails = await client.query(
                `SELECT id FROM bank_details WHERE employee_id = $1`,
                [id]
            );

            if (existingBankDetails.rows.length > 0) {
                // Update existing bank details
                await client.query(
                    `UPDATE bank_details
                     SET
                        account_holder = $1,
                        bank_name = $2,
                        account_number = $3,
                        branch_code = $4,
                        updated_at = CURRENT_TIMESTAMP
                     WHERE employee_id = $5`,
                    [bankDetails.accountHolder, bankDetails.bankName, bankDetails.accountNumber, bankDetails.branchCode || null, id]
                );
            } else if (bankDetails.accountHolder && bankDetails.bankName && bankDetails.accountNumber) {
                // Insert new bank details if they don't exist and are provided
                await client.query(
                    `INSERT INTO bank_details (employee_id, account_holder, bank_name, account_number, branch_code)
                     VALUES ($1, $2, $3, $4, $5)`,
                    [id, bankDetails.accountHolder, bankDetails.bankName, bankDetails.accountNumber, bankDetails.branchCode || null]
                );
            }
        } else {
             // If bankDetails are explicitly null/undefined, consider deleting existing bank details
             await client.query(`DELETE FROM bank_details WHERE employee_id = $1`, [id]);
        }

        await client.query('COMMIT');
        res.json({ id: id, message: 'Employee updated successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        await client.query('ROLLBACK');
        console.error('Error updating employee:', error);
        res.status(500).json({ error: 'Failed to update employee', detail: error instanceof Error ? error.message : String(error) });
    } finally {
        client.release();
    }
});

// DELETE Employee - No change needed
app.delete('/employees/:id', async (req, res) => {
    const { id } = req.params;
    try {
        // Due to ON DELETE CASCADE, bank_details and time_entries will be deleted automatically
        const result = await pool.query('DELETE FROM employees WHERE id = $1 RETURNING id', [id]);
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Employee not found' });
        }
        res.json({ message: 'Employee deleted successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error deleting employee:', error);
        res.status(500).json({ error: 'Failed to delete employee', detail: error instanceof Error ? error.message : String(error) });
    }
});


/* --- TIME ENTRIES API --- */

// NEW: GET All Time Entries (for dashboard and general list)
app.get('/time-entries', async (req, res) => {
    try {
        const result = await pool.query(`
            SELECT id, employee_id, entry_date as date, hours_worked, notes as description, status, created_at, updated_at
            FROM time_entries
            ORDER BY entry_date DESC, created_at DESC
        `);
        res.json(result.rows);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching all time entries:', error);
        res.status(500).json({ error: 'Failed to fetch all time entries', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Time Entries for a specific employee - No change needed, but ensure it fetches status
app.get('/employees/:employeeId/time-entries', async (req, res) => {
    const { employeeId } = req.params;
    try {
        const result = await pool.query(
            `SELECT id, employee_id, entry_date as date, hours_worked, notes as description, status, created_at, updated_at
             FROM time_entries
             WHERE employee_id = $1
             ORDER BY entry_date DESC`,
            [employeeId]
        );
        res.json(result.rows);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching time entries for employee:', error);
        res.status(500).json({ error: 'Failed to fetch time entries', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Add a new Time Entry for an employee - MODIFIED to return full object and set status
app.post('/employees/:employeeId/time-entries', async (req, res) => {
    const { employeeId } = req.params;
    const { date, hours_worked, description } = req.body; // Use date, hours_worked, description to match frontend payload

    if (!date || hours_worked == null || hours_worked <= 0) {
        return res.status(400).json({ error: 'Date and positive hours worked are required.' });
    }

    try {
        const result = await pool.query(
            `INSERT INTO time_entries (employee_id, entry_date, hours_worked, notes, status)
             VALUES ($1, $2, $3, $4, $5) RETURNING id, employee_id, entry_date as date, hours_worked, notes as description, status`, // Return full object
            [employeeId, date, hours_worked, description || null, 'pending'] // Explicitly set status to 'pending'
        );
        res.status(201).json(result.rows[0]); // Return the created time entry object
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error adding time entry:', error);
        res.status(500).json({ error: 'Failed to add time entry', detail: error instanceof Error ? error.message : String(error) });
    }
});

// PUT Update a specific Time Entry - MODIFIED to allow status update and return full object
app.put('/time-entries/:id', async (req, res) => {
    const { id } = req.params;
    const { date, hours_worked, description, status } = req.body; // Allow status to be updated

    // Build dynamic query parts
    const updates = [];
    const values = [];
    let paramIndex = 1;

    if (date !== undefined) { updates.push(`entry_date = $${paramIndex++}`); values.push(date); }
    if (hours_worked !== undefined) { updates.push(`hours_worked = $${paramIndex++}`); values.push(hours_worked); }
    if (description !== undefined) { updates.push(`notes = $${paramIndex++}`); values.push(description); }
    if (status !== undefined) { updates.push(`status = $${paramIndex++}`); values.push(status); }

    if (updates.length === 0) {
        return res.status(400).json({ error: 'No fields provided for update.' });
    }

    updates.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id); // The ID is the last parameter

    try {
        const result = await pool.query(
            `UPDATE time_entries
             SET ${updates.join(', ')}
             WHERE id = $${paramIndex} RETURNING id, employee_id, entry_date as date, hours_worked, notes as description, status`, // Return updated object
            values
        );

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Time entry not found' });
        }
        res.json(result.rows[0]); // Return the updated time entry object
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error updating time entry:', error);
        res.status(500).json({ error: 'Failed to update time entry', detail: error instanceof Error ? error.message : String(error) });
    }
});

// DELETE a specific Time Entry - No change needed
app.delete('/time-entries/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const result = await pool.query('DELETE FROM time_entries WHERE id = $1 RETURNING id', [id]);
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Time entry not found' });
        }
        res.json({ message: 'Time entry deleted successfully' });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error deleting time entry:', error);
        res.status(500).json({ error: 'Failed to delete time entry', detail: error instanceof Error ? error.message : String(error) });
    }
});

/* **START OF REPLACED/MODIFIED SUPPLIER ROUTES** */

/* --- Supplier API (Replacing existing /vendors routes) --- */

// GET All Suppliers (and filter by search term if provided)
app.get('/api/suppliers', async (req, res) => {
    // Asserting req.query.search as string to allow .toLowerCase()
    const searchTerm = req.query.search as string | undefined;

    let query = 'SELECT id, name, email, phone, address, vat_number, total_purchased FROM public.suppliers';
    const queryParams: (string | number)[] = [];
    let paramIndex = 1;

    if (searchTerm) {
        query += ` WHERE LOWER(name) ILIKE $${paramIndex} OR LOWER(email) ILIKE $${paramIndex}`;
        queryParams.push(`%${searchTerm.toLowerCase()}%`);
    }

    query += ' ORDER BY name ASC';

    try {
        const { rows } = await pool.query<SupplierDB>(query, queryParams);
        const formattedRows = rows.map(mapSupplierToFrontend);
        res.json(formattedRows);
    } catch (error: unknown) { // Explicitly type error as unknown
        console.error('Error fetching suppliers:', error);
        res.status(500).json({ error: 'Failed to fetch suppliers', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET a single supplier by ID (useful for "Eye" button or detailed view)
app.get('/api/suppliers/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const { rows } = await pool.query<SupplierDB>(
            'SELECT id, name, email, phone, address, vat_number, total_purchased FROM public.suppliers WHERE id = $1',
            [id]
        );

        if (rows.length === 0) {
            return res.status(404).json({ error: 'Supplier not found' });
        }
        res.json(mapSupplierToFrontend(rows[0]));
    } catch (error: unknown) {
        console.error(`Error fetching supplier with ID ${id}:`, error);
        res.status(500).json({ error: 'Failed to fetch supplier', detail: error instanceof Error ? error.message : String(error) });
    }
});


// POST Create New Supplier
app.post('/api/suppliers', async (req, res) => {
    const { name, email, phone, address, vatNumber } = req.body;

    if (!name) {
        return res.status(400).json({ error: 'Supplier name is required' });
    }

    try {
        const result = await pool.query<SupplierDB>(
            `INSERT INTO public.suppliers (name, email, phone, address, vat_number)
             VALUES ($1, $2, $3, $4, $5) RETURNING id, name, email, phone, address, vat_number, total_purchased`,
            [name, email || null, phone || null, address || null, vatNumber || null]
        );
        res.status(201).json(mapSupplierToFrontend(result.rows[0]));
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error adding supplier:', error);
        if (error instanceof Error && 'code' in error && error.code === '23505') { // Check for unique violation
            return res.status(409).json({ error: 'A supplier with this email or VAT number already exists.' });
        }
        res.status(500).json({ error: 'Failed to add supplier', detail: error instanceof Error ? error.message : String(error) });
    }
});

// PUT Update Existing Supplier
app.put('/api/suppliers/:id', async (req, res) => {
    const { id } = req.params;
    const { name, email, phone, address, vatNumber } = req.body;

    if (!name) { // Name is required for update
        return res.status(400).json({ error: 'Supplier name is required for update.' });
    }

    try {
        const result = await pool.query<SupplierDB>(
            `UPDATE public.suppliers
             SET name = $1, email = $2, phone = $3, address = $4, vat_number = $5, updated_at = CURRENT_TIMESTAMP
             WHERE id = $6 RETURNING id, name, email, phone, address, vat_number, total_purchased`,
            [name, email || null, phone || null, address || null, vatNumber || null, id]
        );

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Supplier not found.' });
        }
        res.json(mapSupplierToFrontend(result.rows[0]));
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error(`Error updating supplier with ID ${id}:`, error);
        if (error instanceof Error && 'code' in error && error.code === '23505') {
            return res.status(409).json({ error: 'A supplier with this email or VAT number already exists.' });
        }
        res.status(500).json({ error: 'Failed to update supplier', detail: error instanceof Error ? error.message : String(error) });
    }
});

// DELETE a Supplier
app.delete('/api/suppliers/:id', async (req, res) => {
    const { id } = req.params;

    try {
        const { rowCount } = await pool.query(
            'DELETE FROM public.suppliers WHERE id = $1',
            [id]
        );

        if (rowCount === 0) {
            return res.status(404).json({ error: 'Supplier not found.' });
        }
        res.status(204).send(); // No Content for successful deletion
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error(`Error deleting supplier with ID ${id}:`, error);
        if (error instanceof Error && 'code' in error && error.code === '23503') { // PostgreSQL foreign key violation error
            return res.status(409).json({
                error: 'Cannot delete supplier: associated with existing purchase orders or other records.',
                detail: error.message
            });
        }
        res.status(500).json({ error: 'Failed to delete supplier', detail: error instanceof Error ? error.message : String(error) });
    }
});

/* --- Product API Endpoints --- */

// Helper function to get tax_rate_id from vatRate (value)
// This will be used in POST and PUT operations
const getTaxRateIdFromVatRate = async (rate: number | undefined): Promise<number | null> => {
    if (rate === undefined || rate === null) {
        return null;
    }
    try {
        const { rows } = await pool.query<{ tax_rate_id: number }>('SELECT tax_rate_id FROM public.tax_rates WHERE rate = $1', [rate]);
        if (rows.length > 0) {
            return rows[0].tax_rate_id;
        }
        // Optionally, if the rate doesn't exist, you could insert it here,
        // or return null and let the calling function handle it (e.g., error).
        // For simplicity, we'll return null if not found.
        return null;
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching tax_rate_id by rate:', error);
        return null; // Or throw to propagate the error
    }
};


// GET All Products (with optional search)
// Path: /api/products
app.get('/api/products', async (req, res) => {
    const searchTerm = req.query.search as string | undefined;

    let query = `
        SELECT
            ps.id, ps.name, ps.description, ps.unit_price, ps.cost_price, ps.sku,
            ps.is_service, ps.stock_quantity, ps.created_at, ps.updated_at,
            ps.tax_rate_id, ps.category, ps.unit, tr.rate AS tax_rate_value
        FROM public.products_services ps
        LEFT JOIN public.tax_rates tr ON ps.tax_rate_id = tr.tax_rate_id
    `;
    const queryParams: (string | number)[] = [];
    let paramIndex = 1;

    if (searchTerm) {
        // Search across name, description, SKU, or category
        query += ` WHERE LOWER(ps.name) ILIKE $${paramIndex} OR LOWER(ps.description) ILIKE $${paramIndex} OR LOWER(ps.sku) ILIKE $${paramIndex} OR LOWER(ps.category) ILIKE $${paramIndex}`;
        queryParams.push(`%${searchTerm.toLowerCase()}%`);
    }

    query += ' ORDER BY ps.name ASC';

    try {
        const { rows } = await pool.query<ProductDB>(query, queryParams);
        const formattedRows = rows.map(mapProductToFrontend);
        res.json(formattedRows);
    } catch (error: unknown) {
        console.error('Error fetching products:', error);
        res.status(500).json({ error: 'Failed to fetch products', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET a single product by ID
// Path: /api/products/:id
app.get('/api/products/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const { rows } = await pool.query<ProductDB>(
            `SELECT
                ps.id, ps.name, ps.description, ps.unit_price, ps.cost_price, ps.sku,
                ps.is_service, ps.stock_quantity, ps.created_at, ps.updated_at,
                ps.tax_rate_id, ps.category, ps.unit, tr.rate AS tax_rate_value
             FROM public.products_services ps
             LEFT JOIN public.tax_rates tr ON ps.tax_rate_id = tr.tax_rate_id
             WHERE ps.id = $1`,
            [id]
        );

        if (rows.length === 0) {
            return res.status(404).json({ error: 'Product not found' });
        }
        res.json(mapProductToFrontend(rows[0]));
    } catch (error: unknown) {
        console.error(`Error fetching product with ID ${id}:`, error);
        res.status(500).json({ error: 'Failed to fetch product', detail: error instanceof Error ? error.message : String(error) });
    }
});

// POST Create New Product
// Path: /api/products
app.post('/api/products', async (req, res) => {
    const {
        name, description, price, costPrice, sku,
        isService = false, stock = 0, vatRate, category, unit
    }: CreateUpdateProductBody = req.body;

    // Basic validation
    if (!name || price === undefined || price === null) {
        return res.status(400).json({ error: 'Product name and price are required.' });
    }
    if (typeof price !== 'number' || price < 0) {
        return res.status(400).json({ error: 'Price must be a non-negative number.' });
    }

    const taxRateId = await getTaxRateIdFromVatRate(vatRate);

    // If vatRate was provided but no matching tax_rate_id was found
    if (vatRate !== undefined && vatRate !== null && taxRateId === null) {
        return res.status(400).json({ error: `Provided VAT rate ${vatRate} does not exist in tax_rates.` });
    }

    try {
        const result = await pool.query<ProductDB>(
            `INSERT INTO public.products_services (
                name, description, unit_price, cost_price, sku, is_service,
                stock_quantity, tax_rate_id, category, unit
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            RETURNING
                id, name, description, unit_price, cost_price, sku,
                is_service, stock_quantity, created_at, updated_at,
                tax_rate_id, category, unit`,
            [
                name,
                description || null,
                price,
                costPrice || null,
                sku || null,
                isService,
                stock,
                taxRateId, // Use the looked-up ID
                category || null,
                unit || null
            ]
        );

        // Fetch the tax rate value again to include in the frontend response
        const newProductDb = result.rows[0];
        if (newProductDb.tax_rate_id) {
            const { rows: taxRows } = await pool.query<{ rate: number }>('SELECT rate FROM public.tax_rates WHERE tax_rate_id = $1', [newProductDb.tax_rate_id]);
            if (taxRows.length > 0) {
                newProductDb.tax_rate_value = taxRows[0].rate;
            }
        }
        res.status(201).json(mapProductToFrontend(newProductDb));

    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error adding product:', error);
        if (error instanceof Error && 'code' in error) {
            if (error.code === '23505') { // Unique violation (e.g., duplicate SKU)
                return res.status(409).json({ error: 'A product with this SKU already exists.' });
            }
            if (error.code === '23503') { // Foreign key violation (should be caught by taxRateId check, but as a fallback)
                 return res.status(400).json({ error: 'Invalid VAT rate ID provided.', detail: error.message });
            }
        }
        res.status(500).json({ error: 'Failed to add product', detail: error instanceof Error ? error.message : String(error) });
    }
});

// PUT Update Existing Product
// Path: /api/products/:id
app.put('/api/products/:id', async (req, res) => {
    const { id } = req.params;
    const {
        name, description, price, costPrice, sku,
        isService, stock, vatRate, category, unit
    }: CreateUpdateProductBody = req.body;

    // Construct dynamic update query
    const updates: string[] = [];
    const values: (string | number | boolean | null)[] = [];
    let paramIndex = 1;

    if (name !== undefined) { updates.push(`name = $${paramIndex++}`); values.push(name); }
    if (description !== undefined) { updates.push(`description = $${paramIndex++}`); values.push(description || null); }
    if (price !== undefined) {
        if (typeof price !== 'number' || price < 0) {
            return res.status(400).json({ error: 'Price must be a non-negative number.' });
        }
        updates.push(`unit_price = $${paramIndex++}`); values.push(price);
    }
    if (costPrice !== undefined) { updates.push(`cost_price = $${paramIndex++}`); values.push(costPrice || null); }
    if (sku !== undefined) { updates.push(`sku = $${paramIndex++}`); values.push(sku || null); }
    if (isService !== undefined) { updates.push(`is_service = $${paramIndex++}`); values.push(isService); }
    if (stock !== undefined) { updates.push(`stock_quantity = $${paramIndex++}`); values.push(stock); }
    if (category !== undefined) { updates.push(`category = $${paramIndex++}`); values.push(category || null); }
    if (unit !== undefined) { updates.push(`unit = $${paramIndex++}`); values.push(unit || null); }

    let taxRateId: number | null | undefined;
    if (vatRate !== undefined) {
        taxRateId = await getTaxRateIdFromVatRate(vatRate);
        if (vatRate !== null && taxRateId === null) { // Only error if vatRate was provided but not found
             return res.status(400).json({ error: `Provided VAT rate ${vatRate} does not exist in tax_rates.` });
        }
        updates.push(`tax_rate_id = $${paramIndex++}`); values.push(taxRateId);
    }


    if (updates.length === 0) {
        return res.status(400).json({ error: 'No fields provided for update.' });
    }

    updates.push(`updated_at = CURRENT_TIMESTAMP`); // Always update timestamp

    const query = `UPDATE public.products_services SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING id, name, description, unit_price, cost_price, sku, is_service, stock_quantity, created_at, updated_at, tax_rate_id, category, unit`;
    values.push(id);

    try {
        const result = await pool.query<ProductDB>(query, values);

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Product not found.' });
        }
        // Re-fetch the tax rate value to include in the frontend response if it changed or wasn't there
        const updatedProductDb = result.rows[0];
        if (updatedProductDb.tax_rate_id) {
            const { rows: taxRows } = await pool.query<{ rate: number }>('SELECT rate FROM public.tax_rates WHERE tax_rate_id = $1', [updatedProductDb.tax_rate_id]);
            if (taxRows.length > 0) {
                updatedProductDb.tax_rate_value = taxRows[0].rate;
            }
        }
        res.json(mapProductToFrontend(updatedProductDb));

    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error(`Error updating product with ID ${id}:`, error);
        if (error instanceof Error && 'code' in error) {
            if (error.code === '23505') { // Unique violation (e.g., duplicate SKU)
                return res.status(409).json({ error: 'A product with this SKU already exists.' });
            }
            if (error.code === '23503') { // Foreign key violation
                 return res.status(400).json({ error: 'Invalid VAT rate ID provided.', detail: error.message });
            }
        }
        res.status(500).json({ error: 'Failed to update product', detail: error instanceof Error ? error.message : String(error) });
    }
});

// DELETE a Product
// Path: /api/products/:id
app.delete('/api/products/:id', async (req, res) => {
    const { id } = req.params;

    try {
        const { rowCount } = await pool.query(
            'DELETE FROM public.products_services WHERE id = $1',
            [id]
        );

        if (rowCount === 0) {
            return res.status(404).json({ error: 'Product not found.' });
        }
        res.status(204).send(); // No Content for successful deletion
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error(`Error deleting product with ID ${id}:`, error);
        if (error instanceof Error && 'code' in error && error.code === '23503') { // Foreign key violation (product might be in an invoice line item)
            return res.status(409).json({
                error: 'Cannot delete product: associated with existing records (e.g., invoices).',
                detail: error.message
            });
        }
        res.status(500).json({ error: 'Failed to delete product', detail: error instanceof Error ? error.message : String(error) });
    }
});

/* --- Stats API Endpoints --- */

// Helper function to calculate change percentage and type
const calculateChange = (current: number, previous: number) => {
    if (previous === 0 && current === 0) {
        return { changePercentage: 0, changeType: 'neutral' };
    }
    if (previous === 0) { // If previous was 0 and current is not, it's an increase
        return { changePercentage: 100, changeType: 'increase' }; // Or a very large number, but 100% is clear
    }
    const percentage = ((current - previous) / previous) * 100;
    let changeType: 'increase' | 'decrease' | 'neutral' = 'neutral';
    if (percentage > 0) {
        changeType = 'increase';
    } else if (percentage < 0) {
        changeType = 'decrease';
    }
    return { changePercentage: parseFloat(percentage.toFixed(2)), changeType };
};

// Define a common date range for "current" and "previous" periods (e.g., last 30 days vs. prior 30 days)
const getCurrentAndPreviousDateRanges = () => {
    const now = new Date();
    const currentPeriodEnd = now.toISOString();

    const currentPeriodStart = new Date();
    currentPeriodStart.setDate(now.getDate() - 30); // Last 30 days
    const currentPeriodStartISO = currentPeriodStart.toISOString();

    const previousPeriodEnd = currentPeriodStart.toISOString();
    const previousPeriodStart = new Date(currentPeriodStart);
    previousPeriodStart.setDate(currentPeriodStart.getDate() - 30); // 30 days before that
    const previousPeriodStartISO = previousPeriodStart.toISOString();

    return {
        currentStart: currentPeriodStartISO,
        currentEnd: currentPeriodEnd,
        previousStart: previousPeriodStartISO,
        previousEnd: previousPeriodEnd
    };
};


// GET Client Count with Change
app.get('/api/stats/clients', async (req, res) => {
    try {
        const { currentStart, currentEnd, previousStart, previousEnd } = getCurrentAndPreviousDateRanges();

        const currentResult = await pool.query(
            'SELECT COUNT(id) AS count FROM public.customers WHERE created_at >= $1 AND created_at <= $2',
            [currentStart, currentEnd]
        );
        const previousResult = await pool.query(
            'SELECT COUNT(id) AS count FROM public.customers WHERE created_at >= $1 AND created_at < $2',
            [previousStart, previousEnd]
        );

        const currentCount = parseInt(currentResult.rows[0].count, 10);
        const previousCount = parseInt(previousResult.rows[0].count, 10);

        const { changePercentage, changeType } = calculateChange(currentCount, previousCount);

        res.json({
            count: currentCount,
            previousCount: previousCount,
            changePercentage: changePercentage,
            changeType: changeType
        });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching client count:', error);
        res.status(500).json({ error: 'Failed to fetch client count', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Quotes Count with Change
app.get('/api/stats/quotes', async (req, res) => {
    try {
        const { currentStart, currentEnd, previousStart, previousEnd } = getCurrentAndPreviousDateRanges();

        const currentResult = await pool.query(
            'SELECT COUNT(id) AS count FROM public.quotations WHERE created_at >= $1 AND created_at <= $2',
            [currentStart, currentEnd]
        );
        const previousResult = await pool.query(
            'SELECT COUNT(id) AS count FROM public.quotations WHERE created_at >= $1 AND created_at < $2',
            [previousStart, previousEnd]
        );

        const currentCount = parseInt(currentResult.rows[0].count, 10);
        const previousCount = parseInt(previousResult.rows[0].count, 10);

        const { changePercentage, changeType } = calculateChange(currentCount, previousCount);

        res.json({
            count: currentCount,
            previousCount: previousCount,
            changePercentage: changePercentage,
            changeType: changeType
        });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching quote count:', error);
        res.status(500).json({ error: 'Failed to fetch quote count', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Invoices Count with Change
app.get('/api/stats/invoices', async (req, res) => {
    try {
        const { currentStart, currentEnd, previousStart, previousEnd } = getCurrentAndPreviousDateRanges();

        const currentResult = await pool.query(
            'SELECT COUNT(id) AS count FROM public.invoices WHERE created_at >= $1 AND created_at <= $2',
            [currentStart, currentEnd]
        );
        const previousResult = await pool.query(
            'SELECT COUNT(id) AS count FROM public.invoices WHERE created_at >= $1 AND created_at < $2',
            [previousStart, previousEnd]
        );

        const currentCount = parseInt(currentResult.rows[0].count, 10);
        const previousCount = parseInt(previousResult.rows[0].count, 10);

        const { changePercentage, changeType } = calculateChange(currentCount, previousCount);

        res.json({
            count: currentCount,
            previousCount: previousCount,
            changePercentage: changePercentage,
            changeType: changeType
        });
    } catch (error: unknown) // Changed 'err' to 'error: unknown'
    {
        console.error('Error fetching invoice count:', error);
        res.status(500).json({ error: 'Failed to fetch invoice count', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Total Invoice Value with Change
app.get('/api/stats/invoice-value', async (req, res) => {
    try {
        const { currentStart, currentEnd, previousStart, previousEnd } = getCurrentAndPreviousDateRanges();

        const currentResult = await pool.query(
            'SELECT COALESCE(SUM(total_amount), 0) AS value FROM public.invoices WHERE created_at >= $1 AND created_at <= $2',
            [currentStart, currentEnd]
        );
        const previousResult = await pool.query(
            'SELECT COALESCE(SUM(total_amount), 0) AS value FROM public.invoices WHERE created_at >= $1 AND created_at < $2',
            [previousStart, previousEnd]
        );

        const currentValue = parseFloat(currentResult.rows[0].value);
        const previousValue = parseFloat(previousResult.rows[0].value);

        const { changePercentage, changeType } = calculateChange(currentValue, previousValue);

        res.json({
            value: currentValue,
            previousValue: previousValue,
            changePercentage: changePercentage,
            changeType: changeType
        });
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching total invoice value:', error);
        res.status(500).json({ error: 'Failed to fetch total invoice value', detail: error instanceof Error ? error.message : String(error) });
    }
});
// STAT APIs
// Helper to format month to YYYY-MM
const formatMonth = (date: Date) => {
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
};

// GET Revenue Trend Data (Profit, Expenses, Revenue by Month)
app.get('/api/charts/revenue-trend', async (req, res) => {
    try {
        // Fetch invoice revenue by month
        // Using 'created_at' for consistency across transaction tables
        const invoicesResult = await pool.query(`
            SELECT
                TO_CHAR(created_at, 'YYYY-MM') AS month,
                COALESCE(SUM(total_amount), 0) AS revenue
            FROM public.invoices
            GROUP BY month
            ORDER BY month;
        `);

        // Fetch expenses by month (assuming an 'expenses' table with 'amount' and a date column)
        // IMPORTANT: Verify the column name for date in your 'public.expenses' table.
        // It is currently assumed to be 'date'. If it's different (e.g., 'created_at'), please change it.
        const expensesResult = await pool.query(`
            SELECT
                TO_CHAR(date, 'YYYY-MM') AS month,
                COALESCE(SUM(amount), 0) AS expenses
            FROM public.transactions /* Changed to transactions table for expense data */
            WHERE type = 'expense'
            GROUP BY month
            ORDER BY month;
        `);

        const revenueMap = new Map<string, { revenue: number, expenses: number }>();

        // Populate revenue and initialize expenses
        invoicesResult.rows.forEach(row => {
            revenueMap.set(row.month, { revenue: parseFloat(row.revenue), expenses: 0 });
        });

        // Add expenses to the map
        expensesResult.rows.forEach(row => {
            if (revenueMap.has(row.month)) {
                const existing = revenueMap.get(row.month)!;
                existing.expenses = parseFloat(row.expenses);
            } else {
                revenueMap.set(row.month, { revenue: 0, expenses: parseFloat(row.expenses) });
            }
        });

        // Consolidate and calculate profit
        const monthlyData: { month: string; profit: number; expenses: number; revenue: number }[] = [];
        const sortedMonths = Array.from(revenueMap.keys()).sort();

        sortedMonths.forEach(month => {
            const data = revenueMap.get(month)!;
            const profit = data.revenue - data.expenses;
            monthlyData.push({
                month,
                profit: parseFloat(profit.toFixed(2)),
                expenses: parseFloat(data.expenses.toFixed(2)), // Ensure expenses are positive for display
                revenue: parseFloat(data.revenue.toFixed(2))
            });
        });

        res.json(monthlyData);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching revenue trend data:', error);
        res.status(500).json({ error: 'Failed to fetch revenue trend data', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET Transaction Volume Data (Quotes, Invoices, Purchases by Month)
app.get('/api/charts/transaction-volume', async (req, res) => {
    try {
        // Fetch quotes count by month
        // Using 'created_at' as per your provided schema for consistency
        const quotesResult = await pool.query(`
            SELECT
                TO_CHAR(created_at, 'YYYY-MM') AS month,
                COUNT(id) AS count
            FROM public.quotations
            GROUP BY month
            ORDER BY month;
        `);

        // Fetch invoices count by month
        // Using 'created_at' as per your provided schema for consistency
        const invoicesResult = await pool.query(`
            SELECT
                TO_CHAR(created_at, 'YYYY-MM') AS month,
                COUNT(id) AS count
            FROM public.invoices
            GROUP BY month
            ORDER BY month;
        `);

        // Fetch purchases count by month
        // Using 'created_at' as per your provided schema for consistency
        const purchasesResult = await pool.query(`
            SELECT
                TO_CHAR(created_at, 'YYYY-MM') AS month,
                COUNT(id) AS count
            FROM public.purchases
            GROUP BY month
            ORDER BY month;
        `);

        const monthlyMap = new Map<string, { quotes: number; invoices: number; purchases: number }>();

        // Populate map with all months and initialize counts
        quotesResult.rows.forEach(row => {
            monthlyMap.set(row.month, { quotes: parseInt(row.count, 10), invoices: 0, purchases: 0 });
        });
        purchasesResult.rows.forEach(row => {
            if (monthlyMap.has(row.month)) {
                monthlyMap.get(row.month)!.purchases = parseInt(row.count, 10);
            } else {
                monthlyMap.set(row.month, { quotes: 0, invoices: 0, purchases: parseInt(row.count, 10) });
            }
        });
        invoicesResult.rows.forEach(row => {
            if (monthlyMap.has(row.month)) {
                monthlyMap.get(row.month)!.invoices = parseInt(row.count, 10);
            } else {
                monthlyMap.set(row.month, { quotes: 0, invoices: parseInt(row.count, 10), purchases: 0 });
            }
        });

        // Sort months and convert to array
        const sortedMonths = Array.from(monthlyMap.keys()).sort();
        const monthlyData: { month: string; quotes: number; invoices: number; purchases: number }[] = [];

        sortedMonths.forEach(month => {
            monthlyData.push({
                month,
                quotes: monthlyMap.get(month)?.quotes || 0,
                invoices: monthlyMap.get(month)?.invoices || 0,
                purchases: monthlyMap.get(month)?.purchases || 0,
            });
        });

        res.json(monthlyData);
    } catch (error: unknown) { // Changed 'err' to 'error: unknown'
        console.error('Error fetching transaction volume data:', error);
        res.status(500).json({ error: 'Failed to fetch transaction volume data', detail: error instanceof Error ? error.message : String(error) });
    }
});

// Upload endpoint
app.post('/documents', upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    const { name, type, description, user_id } = req.body;

    if (!file) return res.status(400).json({ error: 'No file uploaded' });

    const fileUrl = `/uploads/${file.filename}`;
    const mimeType = file.mimetype;
    const fileSize = file.size;

    const result = await pool.query(
      `INSERT INTO documents (user_id, name, type, description, file_url, file_mime_type, file_size_bytes)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [user_id, name, type, description, fileUrl, mimeType, fileSize]
    );

    res.status(201).json(result.rows[0]);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error('Upload error:', error);
    res.status(500).json({ error: 'Something went wrong', detail: error instanceof Error ? error.message : String(error) });
  }
});

// (Optional) Get all documents
app.get('/documents', async (req: Request, res: Response) => {
  try {
    const result = await pool.query('SELECT * FROM documents ORDER BY uploaded_at DESC');
    res.json(result.rows);
  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    res.status(500).json({ error: 'Failed to fetch documents', detail: error instanceof Error ? error.message : String(error) });
  }
});

// Helper function to get status based on progress percentage
const getStatusFromPercentage = (percentage: number): string => {
    if (percentage === 100) {
        return 'Done';
    } else if (percentage >= 75) {
        return 'Review';
    } else if (percentage >= 25) {
        return 'In Progress';
    } else {
        return 'To Do';
    }
};

/* --- Task Management API Endpoints --- */

// POST /api/tasks - Create a new task
app.post('/api/tasks', async (req, res) => {
    const { title, description, priority, due_date, project_id, progress_percentage: clientProgress } = req.body;
    const dummyUserId = 'frontend-user-123';

    if (!title) {
        return res.status(400).json({ error: 'Task title is required.' });
    }

    // Ensure progress_percentage is a number and clamp it between 0 and 100
    const progress_percentage = typeof clientProgress === 'number' ? Math.max(0, Math.min(100, clientProgress)) : 0;
    // Derive status from the provided progress_percentage
    const status = getStatusFromPercentage(progress_percentage);

    try {
        const result = await pool.query(
            `INSERT INTO public.tasks (user_id, title, description, status, priority, due_date, progress_percentage, project_id, created_at)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW()) RETURNING *`,
            [
                dummyUserId,
                title,
                description || null,
                status, // Use derived status
                priority || 'Medium',
                due_date || null,
                progress_percentage, // Use client's progress
                project_id || null
            ]
        );
        res.status(201).json(result.rows[0]);
    } catch (error: unknown) {
        console.error('Error creating task:', error);
        res.status(500).json({ error: 'Failed to create task.', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET /api/tasks - Fetch all tasks for the dummy user, with project details
app.get('/api/tasks', async (req, res) => {
    const dummyUserId = 'frontend-user-123';

    try {
        const result = await pool.query(
            `SELECT t.id, t.title, t.description, t.status, t.priority, t.due_date, t.progress_percentage, t.created_at, t.updated_at,
                    t.project_id, p.name AS project_name, p.description AS project_description, p.deadline AS project_deadline,
                    p.status AS project_status, p.assignee AS project_assignee, p.progress_percentage AS project_overall_progress
             FROM public.tasks t
             LEFT JOIN public.projects p ON t.project_id = p.id
             WHERE t.user_id = $1 ORDER BY t.created_at DESC`, // LEFT JOIN to get project details
            [dummyUserId]
        );
        res.json(result.rows);
    } catch (error: unknown) {
        console.error('Error fetching tasks:', error);
        res.status(500).json({ error: 'Failed to fetch tasks.', detail: error instanceof Error ? error.message : String(error) });
    }
});

// PUT /api/tasks/:id - Update an existing task
app.put('/api/tasks/:id', async (req, res) => {
    const { id } = req.params;
    const { title, description, priority, due_date, project_id, progress_percentage: clientProgress } = req.body;
    const dummyUserId = 'frontend-user-123';

    if (!title) {
        return res.status(400).json({ error: 'Task title is required.' });
    }

    // Ensure progress_percentage is a number and clamp it between 0 and 100
    const progress_percentage = typeof clientProgress === 'number' ? Math.max(0, Math.min(100, clientProgress)) : 0;
    // Derive status from the provided progress_percentage
    const status = getStatusFromPercentage(progress_percentage);

    try {
        const result = await pool.query(
            `UPDATE public.tasks
             SET title = $1, description = $2, status = $3, priority = $4, due_date = $5, progress_percentage = $6, project_id = $7, updated_at = NOW()
             WHERE id = $8 AND user_id = $9 RETURNING *`,
            [
                title,
                description || null,
                status, // Use derived status
                priority || 'Medium',
                due_date || null,
                progress_percentage, // Use client's progress
                project_id || null,
                id,
                dummyUserId
            ]
        );

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Task not found or unauthorized.' });
        }
        res.json(result.rows[0]);
    } catch (error: unknown) {
        console.error('Error updating task:', error);
        res.status(500).json({ error: 'Failed to update task.', detail: error instanceof Error ? error.message : String(error) });
    }
});

// DELETE /api/tasks/:id - Delete a task (no changes needed here)
app.delete('/api/tasks/:id', async (req, res) => {
    const { id } = req.params;
    const dummyUserId = 'frontend-user-123';

    try {
        const result = await pool.query(
            `DELETE FROM public.tasks WHERE id = $1 AND user_id = $2 RETURNING id`,
            [id, dummyUserId]
        );

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Task not found or unauthorized.' });
        }
        res.status(204).send(); // No Content
    } catch (error: unknown) {
        console.error('Error deleting task:', error);
        res.status(500).json({ error: 'Failed to delete task.', detail: error instanceof Error ? error.message : String(error) });
    }
});

/* --- Project Management API Endpoints --- */

// POST /api/projects - Create a new project
app.post('/api/projects', async (req, res) => {
    const { name, description, deadline, status, assignee, progress_percentage } = req.body;
    // You might want to associate projects with a user, similar to tasks
    // const dummyUserId = 'frontend-user-123';

    if (!name) {
        return res.status(400).json({ error: 'Project name is required.' });
    }

    try {
        const result = await pool.query(
            `INSERT INTO public.projects (name, description, deadline, status, assignee, progress_percentage, created_at, updated_at)
             VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW()) RETURNING *`,
            [
                name,
                description || null,
                deadline || null,
                status || 'Not Started',
                assignee || null,
                progress_percentage || 0.00
            ]
        );
        res.status(201).json(result.rows[0]);
    } catch (error: unknown) {
        console.error('Error creating project:', error);
        res.status(500).json({ error: 'Failed to create project.', detail: error instanceof Error ? error.message : String(error) });
    }
});

// GET /api/projects - Fetch all projects
app.get('/api/projects', async (req, res) => {
    try {
        const result = await pool.query(
            `SELECT id, name, description, deadline, status, assignee, progress_percentage, created_at, updated_at
             FROM public.projects ORDER BY created_at DESC`
        );
        res.json(result.rows);
    } catch (error: unknown) {
        console.error('Error fetching projects:', error);
        res.status(500).json({ error: 'Failed to fetch projects.', detail: error instanceof Error ? error.message : String(error) });
    }
});

// PUT /api/projects/:id - Update an existing project
app.put('/api/projects/:id', async (req, res) => {
    const { id } = req.params;
    const { name, description, deadline, status, assignee, progress_percentage } = req.body;

    if (!name) {
        return res.status(400).json({ error: 'Project name is required.' });
    }

    try {
        const result = await pool.query(
            `UPDATE public.projects
             SET name = $1, description = $2, deadline = $3, status = $4, assignee = $5, progress_percentage = $6, updated_at = NOW()
             WHERE id = $7 RETURNING *`,
            [
                name,
                description || null,
                deadline || null,
                status || 'Not Started',
                assignee || null,
                progress_percentage || 0.00,
                id
            ]
        );

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Project not found.' });
        }
        res.json(result.rows[0]);
    } catch (error: unknown) {
        console.error('Error updating project:', error);
        res.status(500).json({ error: 'Failed to update project.', detail: error instanceof Error ? error.message : String(error) });
    }
});

// DELETE /api/projects/:id - Delete a project
app.delete('/api/projects/:id', async (req, res) => {
    const { id } = req.params;

    try {
        const result = await pool.query(
            `DELETE FROM public.projects WHERE id = $1 RETURNING id`,
            [id]
        );

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Project not found.' });
        }
        res.status(204).send(); // No Content
    } catch (error: unknown) {
        console.error('Error deleting project:', error);
        res.status(500).json({ error: 'Failed to delete project.', detail: error instanceof Error ? error.message : String(error) });
    }
});

/* --- Financial Document Generation API --- */
app.get('/generate-financial-document', async (req, res) => {
  const { documentType, startDate, endDate } = req.query;

  if (!documentType || !startDate || !endDate) {
    return res.status(400).json({ error: 'documentType, startDate, and endDate are required.' });
  }

  // Set response headers for PDF download
  res.writeHead(200, {
    'Content-Type': 'application/pdf',
    'Content-Disposition': `attachment; filename="${documentType}-${startDate}-to-${endDate}.pdf"`
  });

  const doc = new PDFDocument();
  doc.pipe(res); // Pipe the PDF directly to the response stream

  try {
    let companyName = "QUANTILYTIX";

    // Helper function to format currency for PDF
    const formatCurrencyForPdf = (amount: number | null | undefined): string => {
      if (amount === null || amount === undefined) return '-'; // Handle null/undefined balances
      if (amount === 0) return '-';
      return parseFloat(amount.toString()).toLocaleString('en-ZA', { style: 'currency', currency: 'ZAR', minimumFractionDigits: 2 });
    };

    // Common function to draw the header for all documents
    const drawDocumentHeader = (doc: any, companyName: string, documentTitle: string, dateString:
string, disclaimerText: string | null = null) => {
      doc.fontSize(16).font('Helvetica-Bold').text(companyName, { align: 'center' });
      doc.fontSize(14).font('Helvetica').text('MANAGEMENT ACCOUNTS', { align: 'center' });
      doc.moveDown(0.5);
      doc.fontSize(14).text(documentTitle, { align: 'center' });
      doc.fontSize(10).text(dateString, { align: 'center' });
      doc.moveDown();

      if (disclaimerText) {
        doc.fontSize(8).fillColor('red').text(
          disclaimerText,
          { align: 'center', width: doc.page.width - 100, continued: false }
        );
        doc.fillColor('black'); // Reset text color
        doc.moveDown(0.5);
      }
    };

    // Define common column positions for consistency
    const col1X = 50;
    const col2X = 400; // Aligned for values
    const columnWidth = 100; // For right-aligned columns

    switch (documentType) {
      case 'income-statement': {
        const incomeStatementStartDate = startDate as string;
        const incomeStatementEndDate = endDate as string;

        // Fetch revenue transactions for the period
        const incomeQueryResult = await pool.query(
          `
          SELECT
              t.category,
              SUM(t.amount) AS total_amount
          FROM
              transactions t
          WHERE
              t.type = 'income'
              AND t.date >= $1 AND t.date <= $2 /* Inclusive end date */
          GROUP BY
              t.category;
          `,
          [incomeStatementStartDate, incomeStatementEndDate]
        );
        const incomeCategories = incomeQueryResult.rows;

        let totalSales = 0;
        let interestIncome = 0;
        let otherIncome = 0;
        const detailedIncome: { [key: string]: number } = {}; // To store income by category for display

        incomeCategories.forEach(inc => {
            const amount = parseFloat(inc.total_amount);
            if (inc.category === 'Sales Revenue' || inc.category === 'Trading Income') {
                totalSales += amount;
            } else if (inc.category === 'Interest Income') {
                interestIncome += amount;
            } else {
                // Aggregate other specific income categories
                if (detailedIncome[inc.category]) {
                    detailedIncome[inc.category] += amount;
                } else {
                    detailedIncome[inc.category] = amount;
                }
                otherIncome += amount; // Sum all other income for gross income calculation
            }
        });

        // Fetch Cost of Goods Sold
        const cogsQueryResult = await pool.query(
            `
            SELECT
                SUM(t.amount) AS total_cogs
            FROM
                transactions t
            WHERE
                t.type = 'expense' AND t.category = 'Cost of Goods Sold'
                AND t.date >= $1 AND t.date <= $2;
            `,
            [incomeStatementStartDate, incomeStatementEndDate]
        );
        const costOfGoodsSold = parseFloat(cogsQueryResult.rows[0]?.total_cogs || 0);

        // Fetch operating expenses (excluding COGS)
        const expensesQueryResult = await pool.query(
          `
          SELECT
              t.category,
              SUM(t.amount) AS total_amount
          FROM
              transactions t
          WHERE
              t.type = 'expense' AND t.category != 'Cost of Goods Sold' /* Exclude COGS here */
              AND t.date >= $1 AND t.date <= $2 /* Inclusive end date */
          GROUP BY
              t.category;
          `,
          [incomeStatementStartDate, incomeStatementEndDate]
        );
        const expenses = expensesQueryResult.rows;

        const grossProfit = totalSales - costOfGoodsSold;
        const totalExpensesSum = expenses.reduce((sum, exp) => sum + parseFloat(exp.total_amount), 0);
        const netProfitLoss = (grossProfit + interestIncome + otherIncome) - totalExpensesSum;

        drawDocumentHeader(
          doc,
          companyName,
          'INCOME STATEMENT',
          `FOR THE PERIOD ENDED ${new Date(incomeStatementEndDate).toLocaleDateString('en-GB', { day: '2-digit', month: 'long', year: 'numeric' })}`
        );

        // Table Headers
        doc.font('Helvetica-Bold');
        doc.fillColor('#e2e8f0').rect(col1X, doc.y, doc.page.width - 100, 20).fill(); // Background for header
        doc.fillColor('#4a5568').text('Description', col1X + 5, doc.y + 5);
        doc.text('Amount (R)', col2X, doc.y + 5, { width: columnWidth, align: 'right' });
        doc.moveDown(0.5);
        doc.fillColor('black'); // Reset text color
        doc.font('Helvetica');


        // Sales
        doc.text('Sales', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalSales), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown(0.5);
        doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);

        // Less: Cost of Sales
        doc.text('Less: Cost of Sales', col1X, doc.y);
        doc.text(formatCurrencyForPdf(costOfGoodsSold), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown(0.5);
        doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);

        // Gross Profit/ (Loss)
        doc.font('Helvetica-Bold');
        doc.text('Gross Profit / (Loss)', col1X, doc.y);
        doc.text(formatCurrencyForPdf(grossProfit), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.font('Helvetica');

        // Add: Other Income
        if (Object.keys(detailedIncome).length > 0 || interestIncome > 0) {
          doc.text('Add: Other Income', col1X, doc.y);
          doc.moveDown(0.5);
          if (interestIncome > 0) {
            doc.text(`  Interest Income`, col1X + 20, doc.y);
            doc.text(formatCurrencyForPdf(interestIncome), col2X, doc.y, { width: columnWidth, align: 'right' });
            doc.moveDown(0.5);
          }
          for (const category in detailedIncome) {
            // Only list if it's not Sales Revenue or Interest Income (already handled)
            if (category !== 'Sales Revenue' && category !== 'Interest Income') {
              doc.text(`  ${category}`, col1X + 20, doc.y);
              doc.text(formatCurrencyForPdf(detailedIncome[category]), col2X, doc.y, { width: columnWidth, align: 'right' });
              doc.moveDown(0.5);
            }
          }
          doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
        }

        // Gross Income
        doc.font('Helvetica-Bold');
        doc.text('Gross Income', col1X, doc.y);
        doc.text(formatCurrencyForPdf(grossProfit + interestIncome + otherIncome), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.font('Helvetica');

        // Less: Expenses
        doc.text('Less: Expenses', col1X, doc.y);
        doc.moveDown(0.5);
        expenses.forEach(exp => {
          doc.text(`  ${exp.category}`, col1X + 20, doc.y);
          doc.text(formatCurrencyForPdf(parseFloat(exp.total_amount)), col2X, doc.y, { width: columnWidth, align: 'right' });
          doc.moveDown(0.5);
          doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
        });

        // Total Expenses
        doc.font('Helvetica-Bold');
        doc.text('Total Expenses', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalExpensesSum), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.font('Helvetica');

        // NET PROFIT /(LOSS) for the period
        doc.font('Helvetica-Bold');
        // Dynamically set text based on profit or loss
        const netProfitLossText = netProfitLoss >= 0 ? 'NET PROFIT for the period' : 'NET LOSS for the period';
        doc.text(netProfitLossText, col1X, doc.y);
        // Ensure Net Profit/Loss is always positive for display
        doc.text(formatCurrencyForPdf(Math.abs(netProfitLoss)), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown();

        doc.fontSize(8).fillColor('#4a5568').text(`Statement Period: ${new Date(incomeStatementStartDate).toLocaleDateString('en-GB')} to ${new Date(incomeStatementEndDate).toLocaleDateString('en-GB')}`, { align: 'center' });
        doc.fillColor('black');
        doc.moveDown();

        break;
      }

      case 'balance-sheet': {
        const balanceSheetEndDate = endDate as string;

        // Fetch all accounts and calculate their proper balances for balance sheet
        const balanceSheetAccountsResult = await pool.query(
          `
          SELECT
              acc.id,
              acc.name,
              acc.type,
              /* Calculate proper debit and credit totals based on account type and transaction type */
              COALESCE(SUM(CASE
                  /* Assets: Increase with debits (expenses like equipment purchases), decrease with credits */
                  WHEN acc.type = 'Asset' AND t.type = 'expense' THEN t.amount /* Money going out increases assets (like equipment purchase) */
                  WHEN acc.type = 'Asset' AND t.type = 'income' THEN -t.amount /* Money coming in decreases specific assets (like asset sale) */
                  /* Liabilities: Increase with credits (taking on debt), decrease with debits (paying off debt) */
                  WHEN acc.type = 'Liability' AND t.type = 'expense' THEN t.amount /* Taking on debt increases liability */
                  WHEN acc.type = 'Liability' AND t.type = 'income' THEN -t.amount /* Paying off debt decreases liability */
                  /* Equity: Increase with credits (profits), decrease with debits (losses/withdrawals) */
                  WHEN acc.type = 'Equity' AND t.type = 'income' THEN t.amount /* Profit increases equity */
                  WHEN acc.type = 'Equity' AND t.type = 'expense' THEN -t.amount /* Losses decrease equity */
                  ELSE 0
              END), 0) AS balance
          FROM
              accounts acc
          LEFT JOIN
              transactions t ON acc.id = t.account_id AND t.date <= $1
          WHERE acc.type IN ('Asset', 'Liability', 'Equity')
          GROUP BY
              acc.id, acc.name, acc.type
          ORDER BY acc.type, acc.name;
          `,
          [balanceSheetEndDate]
        );

        const allAccounts = balanceSheetAccountsResult.rows;
        const assetsAccounts = allAccounts.filter(a => a.type === 'Asset');
        const liabilityAccounts = allAccounts.filter(a => a.type === 'Liability');
        const equityAccounts = allAccounts.filter(a => a.type === 'Equity');

        // Fetch Fixed Assets with their accumulated depreciation
        const fixedAssetsResult = await pool.query(`
            SELECT
                id, name, cost, accumulated_depreciation
            FROM assets
            WHERE date_received <= $1
            ORDER BY name;
        `, [balanceSheetEndDate]);

        let totalFixedAssetsAtCost = 0;
        let totalAccumulatedDepreciation = 0;
        const fixedAssetsToDisplay: { name: string; cost: number; accumulated_depreciation: number; net_book_value: number }[] = [];

        fixedAssetsResult.rows.forEach(asset => {
            const cost = parseFloat(asset.cost);
            const accumulated_depreciation = parseFloat(asset.accumulated_depreciation);
            const net_book_value = cost - accumulated_depreciation;

            totalFixedAssetsAtCost += cost;
            totalAccumulatedDepreciation += accumulated_depreciation;

            fixedAssetsToDisplay.push({
                name: asset.name,
                cost: cost,
                accumulated_depreciation: accumulated_depreciation,
                net_book_value: net_book_value
            });
        });

        // Calculate retained earnings (accumulated profit/loss from all periods up to end date)
        const currentPeriodProfitLossResult = await pool.query(
          `
          SELECT
              COALESCE(SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE -t.amount END), 0) AS retained_earnings
          FROM
              transactions t
          WHERE
              t.date <= $1;
          `,
          [balanceSheetEndDate] // Calculate all profit/loss up to balance sheet date
        );
        const retainedEarnings = parseFloat(currentPeriodProfitLossResult.rows[0].retained_earnings || 0);

        drawDocumentHeader(
          doc,
          companyName,
          'BALANCE SHEET',
          `AS OF ${new Date(balanceSheetEndDate).toLocaleDateString('en-GB', { day: '2-digit', month: 'long', year: 'numeric' })}`
        );

        // ASSETS SECTION
        doc.font('Helvetica-Bold').fontSize(12).text('ASSETS', col1X, doc.y);
        doc.moveDown(0.5);
        doc.font('Helvetica');

        // Non-current Assets (Fixed Assets)
        doc.font('Helvetica-Bold').text('Non-current Assets', col1X, doc.y);
        doc.moveDown(0.5);

        if (fixedAssetsToDisplay.length > 0) {
            doc.text('  Fixed Assets at Cost:', col1X + 20, doc.y);
            doc.text(formatCurrencyForPdf(totalFixedAssetsAtCost), col2X, doc.y, { width: columnWidth, align: 'right' });
            doc.moveDown(0.5);

            doc.text('  Less: Accumulated Depreciation', col1X + 20, doc.y);
            doc.text(formatCurrencyForPdf(totalAccumulatedDepreciation), col2X, doc.y, { width: columnWidth, align: 'right' });
            doc.moveDown(0.5);
            doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
            doc.moveDown(0.5);

            doc.font('Helvetica-Bold');
            doc.text('Net Book Value of Fixed Assets', col1X + 20, doc.y);
            doc.text(formatCurrencyForPdf(totalFixedAssetsAtCost - totalAccumulatedDepreciation), col2X, doc.y, { width: columnWidth, align: 'right' });
            doc.moveDown();
            doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
            doc.moveDown(0.5);
            doc.font('Helvetica');
        } else {
            doc.text('  No Fixed Assets to display.', col1X + 20, doc.y);
            doc.moveDown(1);
        }

        doc.font('Helvetica-Bold');
        doc.text('Total Non-current Assets', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalFixedAssetsAtCost - totalAccumulatedDepreciation), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.font('Helvetica');

        // Current Assets
        doc.font('Helvetica-Bold').text('Current Assets', col1X, doc.y);
        doc.moveDown(0.5);
        let totalCurrentAssets = 0;
        assetsAccounts.filter(a => a.name.toLowerCase().includes('bank') || a.name.toLowerCase().includes('cash') || a.name.toLowerCase().includes('receivable')).forEach(asset => {
          doc.text(`  ${asset.name}`, col1X + 20, doc.y);
          doc.text(formatCurrencyForPdf(asset.balance), col2X, doc.y, { width: columnWidth, align: 'right' });
          totalCurrentAssets += parseFloat(asset.balance);
          doc.moveDown(0.5);
          doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
        });

        doc.font('Helvetica-Bold');
        doc.text('Total Current Assets', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalCurrentAssets), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);

        doc.font('Helvetica-Bold').fontSize(12);
        const totalAssets = (totalFixedAssetsAtCost - totalAccumulatedDepreciation) + totalCurrentAssets;
        doc.text('Total Assets', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalAssets), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown(2);
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown();


        // EQUITY AND LIABILITIES SECTION
        doc.font('Helvetica-Bold').fontSize(12).text('EQUITY AND LIABILITIES', col1X, doc.y);
        doc.moveDown(0.5);
        doc.font('Helvetica');

        // Capital and Reserves
        doc.font('Helvetica-Bold').text('Capital and Reserves', col1X, doc.y);
        doc.moveDown(0.5);
        let totalEquityAccountsBalance = 0;
        equityAccounts.forEach(eq => {
          doc.text(`  ${eq.name}`, col1X + 20, doc.y);
          doc.text(formatCurrencyForPdf(eq.balance), col2X, doc.y, { width: columnWidth, align: 'right' });
          totalEquityAccountsBalance += parseFloat(eq.balance);
          doc.moveDown(0.5);
          doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
        });

        // Add Current Period Profit/Loss to Equity
        // This represents the retained earnings for the current period
        doc.text(`  Retained Earnings`, col1X + 20, doc.y);
        doc.text(formatCurrencyForPdf(retainedEarnings), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown(0.5);
        doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);

        doc.font('Helvetica-Bold');
        const totalEquity = totalEquityAccountsBalance + retainedEarnings;
        doc.text('Total Equity', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalEquity), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.font('Helvetica');

        // Non - Current Liabilities
        doc.font('Helvetica-Bold').text('Non-Current Liabilities', col1X, doc.y);
        doc.moveDown(0.5);
        let totalNonCurrentLiabilities = 0;
        liabilityAccounts.filter(a => a.name.toLowerCase().includes('loan') || a.name.toLowerCase().includes('long-term')).forEach(lib => {
          doc.text(`  ${lib.name}`, col1X + 20, doc.y);
          doc.text(formatCurrencyForPdf(lib.balance), col2X, doc.y, { width: columnWidth, align: 'right' });
          totalNonCurrentLiabilities += parseFloat(lib.balance);
          doc.moveDown(0.5);
          doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
        });

        doc.font('Helvetica-Bold');
        doc.text('Total Non-Current Liabilities', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalNonCurrentLiabilities), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.font('Helvetica');


        // Current Liabilities
        doc.font('Helvetica-Bold').text('Current Liabilities', col1X, doc.y);
        doc.moveDown(0.5);
        let totalCurrentLiabilities = 0;
        liabilityAccounts.filter(a => a.name.toLowerCase().includes('payable') || a.name.toLowerCase().includes('current liability') || a.name.toLowerCase().includes('credit facility')).forEach(lib => {
          doc.text(`  ${lib.name}`, col1X + 20, doc.y);
          doc.text(formatCurrencyForPdf(lib.balance), col2X, doc.y, { width: columnWidth, align: 'right' });
          totalCurrentLiabilities += parseFloat(lib.balance);
          doc.moveDown(0.5);
          doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
        });

        doc.font('Helvetica-Bold');
        doc.text('Total Current Liabilities', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalCurrentLiabilities), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);

        doc.font('Helvetica-Bold').fontSize(12);
        const totalEquityAndLiabilities = totalEquity + totalNonCurrentLiabilities + totalCurrentLiabilities;
        doc.text('Total Equity and Liabilities', col1X, doc.y);
        doc.text(formatCurrencyForPdf(totalEquityAndLiabilities), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown(2);
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown();

        doc.fontSize(8).fillColor('#4a5568').text(`Statement Period: ${new Date(startDate as string).toLocaleDateString('en-GB')} to ${new Date(endDate as string).toLocaleDateString('en-GB')}`, { align: 'center' });
        doc.fillColor('black');
        doc.moveDown();

        break;
      }

      case 'trial-balance': {
        const trialBalanceStartDate = startDate as string;
        const trialBalanceEndDate = endDate as string;

        // Define column positions for trial balance specifically, before use
        const accountNameX = 50;
        const debitX = 350;
        const creditX = 500;
        // columnWidth is already defined globally as 100

        // Step 1: Calculate proper debit/credit balances for each account
        // Modified query to use t.category + t.description for Income/Expense display names
        const netBalancesResult = await pool.query(
          `
          SELECT
              // Use transaction category + description for Income/Expense, otherwise use account name
              CASE
                  WHEN acc.type = 'Income' AND t.category IS NOT NULL THEN COALESCE(t.category, 'Uncategorized Income') || COALESCE(' - ' || t.description, '')
                  WHEN acc.type = 'Expense' AND t.category IS NOT NULL THEN COALESCE(t.category, 'Uncategorized Expense') || COALESCE(' - ' || t.description, '')
                  ELSE acc.name
              END AS account_display_name,
              acc.type AS account_type,
              // Calculate the net balance for each account/category/description combination
              COALESCE(SUM(
                  CASE
                      // For Asset & Expense: Debits increase (+), Credits decrease (-)
                      WHEN acc.type IN ('Asset', 'Expense') THEN
                          CASE
                              WHEN t.type = 'expense' THEN t.amount
                              WHEN t.type = 'income' THEN -t.amount
                              ELSE 0
                          END
                      // For Liability, Equity, Income: Credits increase (+), Debits decrease (-)
                      WHEN acc.type IN ('Liability', 'Equity', 'Income') THEN
                          CASE
                              WHEN t.type = 'income' THEN t.amount
                              WHEN t.type = 'expense' THEN -t.amount
                              ELSE 0
                          END
                      ELSE 0
                  END
              ), 0) AS account_balance
          FROM
              accounts acc
          LEFT JOIN
              transactions t ON acc.id = t.account_id AND t.date <= $1
          GROUP BY
              CASE
                  WHEN acc.type = 'Income' AND t.category IS NOT NULL THEN COALESCE(t.category, 'Uncategorized Income') || COALESCE(' - ' || t.description, '')
                  WHEN acc.type = 'Expense' AND t.category IS NOT NULL THEN COALESCE(t.category, 'Uncategorized Expense') || COALESCE(' - ' || t.description, '')
                  ELSE acc.name
              END,
              acc.type
          HAVING
              COALESCE(SUM(
                  CASE
                      WHEN acc.type IN ('Asset', 'Expense') THEN
                          CASE WHEN t.type = 'expense' THEN t.amount WHEN t.type = 'income' THEN -t.amount ELSE 0 END
                      WHEN acc.type IN ('Liability', 'Equity', 'Income') THEN
                          CASE WHEN t.type = 'income' THEN t.amount WHEN t.type = 'expense' THEN -t.amount ELSE 0 END
                      ELSE 0
                  END
              ), 0) != 0 /* Only include accounts with a non-zero balance */
          ORDER BY
              account_type, account_display_name;
          `,
          [trialBalanceEndDate]
        );

        let trialAccounts = netBalancesResult.rows.map(account => {
          const accountBalance = parseFloat(String(account.account_balance || 0));
          let debitAmount = 0;
          let creditAmount = 0;

          // Determine normal balance side and place amounts accordingly
          if (account.account_type === 'Asset' || account.account_type === 'Expense') {
            // Assets and Expenses have normal debit balances
            if (accountBalance >= 0) {
              debitAmount = accountBalance;
            } else {
              creditAmount = Math.abs(accountBalance); // If negative, it's a credit balance
            }
          } else if (account.account_type === 'Liability' || account.account_type === 'Equity' || account.account_type === 'Income') {
            // Liabilities, Equity, and Income have normal credit balances
            if (accountBalance >= 0) {
              creditAmount = accountBalance;
            } else {
              debitAmount = Math.abs(accountBalance); // If negative, it's a debit balance
            }
          }

          return {
            account_display_name: account.account_display_name,
            account_type: account.account_type, // Keep for sorting/debugging
            debitAmount,
            creditAmount
          };
        });

        // Filter out accounts with zero debit and zero credit to keep the report clean
        trialAccounts = trialAccounts.filter(account => account.debitAmount !== 0 || account.creditAmount !== 0);

        // Calculate totals for rendering
        const totalDebit = trialAccounts.reduce((sum, acc) => sum + acc.debitAmount, 0);
        const totalCredit = trialAccounts.reduce((sum, acc) => sum + acc.creditAmount, 0);

        drawDocumentHeader(
          doc,
          companyName,
          'TRIAL BALANCE',
          `AS OF ${new Date(trialBalanceEndDate).toLocaleDateString('en-GB')}`,
          
        );

        // Table Headers
        doc.font('Helvetica-Bold');
        doc.fillColor('#e2e8f0').rect(col1X, doc.y, doc.page.width - 100, 20).fill(); // Background for header
        doc.fillColor('#4a5568').text('Account Name', accountNameX + 5, doc.y + 5);
        doc.text('Debit (R)', debitX, doc.y + 5, { width: columnWidth, align: 'right' });
        doc.text('Credit (R)', creditX, doc.y + 5, { width: columnWidth, align: 'right' });
        doc.moveDown(0.5);
        doc.fillColor('black'); // Reset text color
        doc.font('Helvetica');


        // === Render Accounts to PDF ===
        trialAccounts.forEach(account => {
          doc.text(account.account_display_name, accountNameX, doc.y);
          doc.text(
            formatCurrencyForPdf(account.debitAmount),
            debitX, doc.y, { width: columnWidth, align: 'right' });

          doc.text(
            formatCurrencyForPdf(account.creditAmount),
            creditX, doc.y, { width: columnWidth, align: 'right' });
          doc.moveDown(0.5);
          doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(creditX + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
        });

        // === Render Totals ===
        doc.font('Helvetica-Bold');
        doc.fillColor('#e2e8f0').rect(col1X, doc.y, doc.page.width - 100, 20).fill(); // Background for totals
        doc.fillColor('#4a5568').text('Total', col1X + 5, doc.y + 5);
        doc.text(formatCurrencyForPdf(totalDebit),
          debitX, doc.y + 5, { width: columnWidth, align: 'right' });
        doc.text(formatCurrencyForPdf(totalCredit),
          creditX, doc.y + 5, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.fillColor('black'); // Reset text color
        doc.font('Helvetica');
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(creditX + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(creditX + columnWidth, doc.y).stroke();
        doc.moveDown();

        doc.fontSize(8).fillColor('#4a5568').text(`Statement Period: ${new Date(trialBalanceStartDate).toLocaleDateString('en-GB')} to ${new Date(trialBalanceEndDate).toLocaleDateString('en-GB')}`, { align: 'center' });
        doc.fillColor('black');
        doc.moveDown();

        break;
      }

      case 'cash-flow-statement': {
        type TransactionRow = {
          type: string;
          category: string;
          amount: number;
        };

        const classify = (row: { category: string }): 'operating' | 'investing' | 'financing' => {
          const cat = (row.category || '').toLowerCase();
          if (['equipment', 'property', 'asset', 'vehicle'].some(k => cat.includes(k))) return 'investing';
          if (['loan', 'members loan', 'shareholders loan', 'credit facility'].some(k => cat.includes(k))) return 'financing';
          return 'operating';
        };

        const cashFlows: { operating: TransactionRow[]; investing: TransactionRow[]; financing: TransactionRow[] } = {
          operating: [],
          investing: [],
          financing: [],
        };

        const rowsResult = await pool.query(
          `SELECT type, category, amount FROM transactions WHERE date >= $1 AND date <= $2 AND (type = 'income' OR type = 'expense');`,
          [startDate, endDate]
        );
        const rows: TransactionRow[] = rowsResult.rows;

        rows.forEach((row) => {
          const section = classify(row);
          const amount = row.type === 'income' ? parseFloat(row.amount as any) : -parseFloat(row.amount as any);
          cashFlows[section].push({ ...row, amount });
        });

        const renderSection = (title: string, items: TransactionRow[]) => {
          doc.font('Helvetica-Bold').fontSize(12).text(title, col1X, doc.y);
          doc.moveDown(0.5);
          doc.font('Helvetica');

          let total = 0;
          items.forEach(item => {
            doc.text(`  ${item.category || 'Uncategorized'}`, col1X + 20, doc.y);
            doc.text(formatCurrencyForPdf(item.amount), col2X, doc.y, { width: columnWidth, align: 'right' });
            total += item.amount;
            doc.moveDown(0.5);
            doc.lineWidth(0.2).strokeColor('#e2e8f0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
            doc.moveDown(0.5);
          });

          doc.font('Helvetica-Bold');
          doc.text(`Net ${title}`, col1X, doc.y);
          doc.text(formatCurrencyForPdf(total), col2X, doc.y, { width: columnWidth, align: 'right' });
          doc.moveDown(1);
          doc.lineWidth(0.5).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
          doc.moveDown(0.5);
          doc.font('Helvetica');

          return total;
        };

        drawDocumentHeader(
          doc,
          companyName,
          'CASH FLOW STATEMENT',
          `FOR THE PERIOD ENDED ${new Date(endDate.toString()).toLocaleDateString('en-GB', { day: '2-digit', month: 'long', year: 'numeric' })}`
        );

        const totalOperating = renderSection('Operating Activities', cashFlows.operating);
        const totalInvesting = renderSection('Investing Activities', cashFlows.investing);
        const totalFinancing = renderSection(
          'Financing Activities',
          cashFlows.financing
        );

        const netIncreaseInCash = totalOperating + totalInvesting + totalFinancing;

        doc.font('Helvetica-Bold').fontSize(12).text('Net Increase / (Decrease) in Cash', col1X, doc.y);
        doc.text(formatCurrencyForPdf(netIncreaseInCash), col2X, doc.y, { width: columnWidth, align: 'right' });
        doc.moveDown();
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown(0.5);
        doc.lineWidth(1).strokeColor('#a0aec0').moveTo(col1X, doc.y).lineTo(col2X + columnWidth, doc.y).stroke();
        doc.moveDown();

        doc.fontSize(8).fillColor('#4a5568').text(`Statement Period: ${new Date(startDate as string).toLocaleDateString('en-GB')} to ${new Date(endDate as string).toLocaleDateString('en-GB')}`, { align: 'center' });
        doc.fillColor('black');
        doc.moveDown();

        break;
      }


      default:
        doc.text('Document type not supported.', { align: 'center' });
        doc.end();
        return;
    }

    doc.end();

  } catch (error: unknown) { // Changed 'err' to 'error: unknown'
    console.error(`Error generating ${documentType}:`, error);
    res.removeHeader('Content-Disposition');
    res.writeHead(500, { 'Content-Type': 'application/json' });

    if (error instanceof Error) {
      res.end(JSON.stringify({ error: `Failed to generate ${documentType}`, details: error.message }));
    } else {
      res.end(JSON.stringify({ error: `Failed to generate ${documentType}`, details: String(error) }));
    }
  }
});


// Assuming app and PORT are defined elsewhere in your server file
// app.listen(PORT, () => {
//   console.log(`Node server running on http://localhost:${PORT}`);
// });



app.listen(PORT, () => {
  console.log(`Node server running on http://localhost:${PORT}`);
});






// Helper function to calculate previous period dates based on the current period
const getPreviousPeriodDates = (startDateStr: string, endDateStr: string) => {
    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);

    // Calculate the duration of the current period in milliseconds
    const periodDurationMs = endDate.getTime() - startDate.getTime();

    // The previous period's end date is the day before the current period's start date
    const prevEndDate = new Date(startDate);
    prevEndDate.setDate(startDate.getDate() - 1);

    // The previous period's start date is `periodDurationMs` before the prevEndDate
    const prevStartDate = new Date(prevEndDate.getTime() - periodDurationMs);

    return {
        prevStartDate: prevStartDate.toISOString().split('T')[0],
        prevEndDate: prevEndDate.toISOString().split('T')[0],
    };
};

// NEW ENDPOINT: GET Revenue Statistics for a period (or all time)
app.get('/api/stats/revenue', authMiddleware, async (req: Request, res: Response) => {
    const user_id = req.user!.parent_user_id;
    // startDate and endDate can now be optional
    const { startDate, endDate } = req.query as { startDate?: string; endDate?: string };

    try {
        let currentPeriodValue = 0;
        let previousPeriodValue = 0;
        let changePercentage: number | undefined;
        let changeType: 'increase' | 'decrease' | 'neutral' = 'neutral';

        let dateFilterClause = '';
        const currentQueryParams: (string | number)[] = [user_id];
        let currentParamIndex = 2;

        // If both startDate and endDate are provided, build the date filter clause
        if (startDate && endDate) {
            dateFilterClause = ` AND date BETWEEN $${currentParamIndex++} AND $${currentParamIndex++}`;
            currentQueryParams.push(startDate);
            currentQueryParams.push(endDate);
        }

        // Fetch current period revenue (or all-time if no dates provided)
        const currentRevenueResult = await pool.query(`
            SELECT COALESCE(SUM(amount), 0) AS value
            FROM public.transactions
            WHERE
                user_id = $1
                AND type = 'income'
                AND category IN ('Revenue', 'Sales Revenue')
                ${dateFilterClause};
        `, currentQueryParams);

        currentPeriodValue = parseFloat(currentRevenueResult.rows[0]?.value || 0);

        // Only calculate previous period and change if a specific date range was provided
        if (startDate && endDate) {
            const { prevStartDate, prevEndDate } = getPreviousPeriodDates(startDate, endDate);
            const previousQueryParams: (string | number)[] = [user_id, prevStartDate, prevEndDate];

            // Fetch previous period revenue
            const previousRevenueResult = await pool.query(`
                SELECT COALESCE(SUM(amount), 0) AS value
                FROM public.transactions
                WHERE
                    user_id = $1
                    AND type = 'income'
                    AND category IN ('Revenue', 'Sales Revenue')
                    AND date BETWEEN $2 AND $3;
            `, previousQueryParams);

            previousPeriodValue = parseFloat(previousRevenueResult.rows[0]?.value || 0);

            // Calculate change percentage
            if (previousPeriodValue !== 0) {
                changePercentage = ((currentPeriodValue - previousPeriodValue) / previousPeriodValue) * 100;
                if (changePercentage > 0) {
                    changeType = 'increase';
                } else if (changePercentage < 0) {
                    changeType = 'decrease';
                }
            } else if (currentPeriodValue > 0) {
                changePercentage = 100; // Infinite increase from zero to a positive value
                changeType = 'increase';
            }
        }

        res.json({
            value: currentPeriodValue,
            previousValue: previousPeriodValue,
            changePercentage: changePercentage !== undefined ? parseFloat(changePercentage.toFixed(2)) : undefined,
            changeType: changeType
        });

    } catch (error: unknown) {
        console.error('Error fetching revenue stats:', error);
        res.status(500).json({ error: 'Failed to fetch revenue statistics', detail: error instanceof Error ? error.message : String(error) });
    }
});

// NEW ENDPOINT: GET Expenses Statistics for a period (or all time)
app.get('/api/stats/expenses', authMiddleware, async (req: Request, res: Response) => {
    const user_id = req.user!.parent_user_id;
    // startDate and endDate can now be optional
    const { startDate, endDate } = req.query as { startDate?: string; endDate?: string };

    try {
        let currentPeriodValue = 0;
        let previousPeriodValue = 0;
        let changePercentage: number | undefined;
        let changeType: 'increase' | 'decrease' | 'neutral' = 'neutral';

        let dateFilterClause = '';
        const currentQueryParams: (string | number)[] = [user_id];
        let currentParamIndex = 2;

        // If both startDate and endDate are provided, build the date filter clause
        if (startDate && endDate) {
            dateFilterClause = ` AND date BETWEEN $${currentParamIndex++} AND $${currentParamIndex++}`;
            currentQueryParams.push(startDate);
            currentQueryParams.push(endDate);
        }

        // Fetch current period expenses (or all-time if no dates provided)
        const currentExpensesResult = await pool.query(`
            SELECT COALESCE(SUM(amount), 0) AS value
            FROM public.transactions
            WHERE
                user_id = $1
                AND type = 'expense'
                ${dateFilterClause};
        `, currentQueryParams);

        currentPeriodValue = parseFloat(currentExpensesResult.rows[0]?.value || 0);

        // Only calculate previous period and change if a specific date range was provided
        if (startDate && endDate) {
            const { prevStartDate, prevEndDate } = getPreviousPeriodDates(startDate, endDate);
            const previousQueryParams: (string | number)[] = [user_id, prevStartDate, prevEndDate];

            // Fetch previous period expenses
            const previousExpensesResult = await pool.query(`
                SELECT COALESCE(SUM(amount), 0) AS value
                FROM public.transactions
                WHERE
                    user_id = $1
                    AND type = 'expense'
                    AND date BETWEEN $2 AND $3;
            `, previousQueryParams);

            previousPeriodValue = parseFloat(previousExpensesResult.rows[0]?.value || 0);

            // Calculate change percentage
            if (previousPeriodValue !== 0) {
                changePercentage = ((currentPeriodValue - previousPeriodValue) / previousPeriodValue) * 100;
                if (changePercentage > 0) { // For expenses, an increase is often seen as a negative trend
                    changeType = 'increase';
                } else if (changePercentage < 0) {
                    changeType = 'decrease';
                }
            } else if (currentPeriodValue > 0) {
                changePercentage = 100; // Infinite increase from zero to a positive value
                changeType = 'increase';
            }
        }

        res.json({
            value: currentPeriodValue,
            previousValue: previousPeriodValue,
            changePercentage: changePercentage !== undefined ? parseFloat(changePercentage.toFixed(2)) : undefined,
            changeType: changeType
        });

    } catch (error: unknown) {
        console.error('Error fetching expenses stats:', error);
        res.status(500).json({ error: 'Failed to fetch expenses statistics', detail: error instanceof Error ? error.message : String(error) });
    }
});

// Existing /api/stats/clients endpoint, modified to allow all-time view and use public.sales
app.get('/api/stats/clients', authMiddleware, async (req: Request, res: Response) => {
    const user_id = req.user!.parent_user_id;
    // startDate and endDate can now be optional
    const { startDate, endDate } = req.query as { startDate?: string; endDate?: string };

    try {
        let currentPeriodCount = 0;
        let previousPeriodCount = 0;
        let changePercentage: number | undefined;
        let changeType: 'increase' | 'decrease' | 'neutral' = 'neutral';

        let dateFilterClause = '';
        const currentQueryParams: (string | number)[] = [user_id];
        let currentParamIndex = 2;

        // If both startDate and endDate are provided, build the date filter clause for 'created_at'
        if (startDate && endDate) {
            dateFilterClause = ` AND created_at BETWEEN $${currentParamIndex++} AND $${currentParamIndex++}`;
            currentQueryParams.push(startDate);
            currentQueryParams.push(endDate);
        }

        // Fetch current period client count (or all-time if no dates provided)
        // Now counting distinct customer_id from public.sales table
        const currentClientsResult = await pool.query(`
            SELECT COUNT(DISTINCT customer_id) AS count
            FROM public.sales
            WHERE user_id = $1
            ${dateFilterClause};
        `, currentQueryParams);
        currentPeriodCount = parseInt(currentClientsResult.rows[0]?.count || 0, 10);

        // Only calculate previous period and change if a specific date range was provided
        if (startDate && endDate) {
            const { prevStartDate, prevEndDate } = getPreviousPeriodDates(startDate, endDate);
            const previousQueryParams: (string | number)[] = [user_id, prevStartDate, prevEndDate];

            // Fetch previous period client count
            // Now counting distinct customer_id from public.sales table
            const previousClientsResult = await pool.query(`
                SELECT COUNT(DISTINCT customer_id) AS count
                FROM public.sales
                WHERE user_id = $1
                AND created_at BETWEEN $2 AND $3;
            `, previousQueryParams);
            previousPeriodCount = parseInt(previousClientsResult.rows[0]?.count || 0, 10);

            // Calculate change percentage
            if (previousPeriodCount !== 0) {
                changePercentage = ((currentPeriodCount - previousPeriodCount) / previousPeriodCount) * 100;
                if (changePercentage > 0) {
                    changeType = 'increase';
                } else if (changePercentage < 0) {
                    changeType = 'decrease';
                }
            } else if (currentPeriodCount > 0) {
                changePercentage = 100; // Infinite increase from zero to a positive value
                changeType = 'increase';
            }
        }

        res.json({
            count: currentPeriodCount,
            previousCount: previousPeriodCount,
            changePercentage: changePercentage !== undefined ? parseFloat(changePercentage.toFixed(2)) : undefined,
            changeType: changeType
        });

    } catch (error: unknown) {
        console.error('Error fetching client stats:', error);
        res.status(500).json({ error: 'Failed to fetch client statistics', detail: error instanceof Error ? error.message : String(error) });
    }
});


// Add this new endpoint to your server.ts file, e.g., after the quotes endpoint.
app.get('/api/stats/profitability', authMiddleware, async (req: Request, res: Response) => {
  const user_id = req.user!.parent_user_id;
  const { startDate, endDate } = req.query;

  try {
    let dateFilter = '';
    const queryParams: (string | number)[] = [user_id];
    let paramIndex = 2;

    if (startDate) {
      dateFilter += ` AND date >= $${paramIndex++}`;
      queryParams.push(startDate as string);
    }
    if (endDate) {
      dateFilter += ` AND date <= $${paramIndex++}`;
      queryParams.push(endDate as string);
    }

    // Get total income
    const incomeResult = await pool.query(
      `SELECT COALESCE(SUM(amount), 0) AS total_income FROM public.transactions WHERE user_id = $1 AND type = 'income' ${dateFilter};`,
      queryParams
    );
    const totalIncome = parseFloat(incomeResult.rows[0]?.total_income || 0);

    // Get total expenses
    const expensesResult = await pool.query(
      `SELECT COALESCE(SUM(amount), 0) AS total_expenses FROM public.transactions WHERE user_id = $1 AND type = 'expense' ${dateFilter};`,
      queryParams
    );
    const totalExpenses = parseFloat(expensesResult.rows[0]?.total_expenses || 0);

    // Get previous period income
    const { currentStart, previousStart, previousEnd } = getCurrentAndPreviousDateRanges();

    const previousIncomeResult = await pool.query(
        `SELECT COALESCE(SUM(amount), 0) AS total_income FROM public.transactions WHERE user_id = $1 AND type = 'income' AND date >= $2 AND date < $3;`,
        [user_id, previousStart, currentStart]
    );
    const previousIncome = parseFloat(previousIncomeResult.rows[0]?.total_income || 0);

    // Get previous period expenses
    const previousExpensesResult = await pool.query(
        `SELECT COALESCE(SUM(amount), 0) AS total_expenses FROM public.transactions WHERE user_id = $1 AND type = 'expense' AND date >= $2 AND date < $3;`,
        [user_id, previousStart, currentStart]
    );
    const previousExpenses = parseFloat(previousExpensesResult.rows[0]?.total_expenses || 0);


    const currentProfit = totalIncome - totalExpenses;
    const previousProfit = previousIncome - previousExpenses;
    const { changePercentage, changeType } = calculateChange(currentProfit, previousProfit);

    res.status(200).json({
      value: currentProfit,
      previousValue: previousProfit,
      changePercentage,
      changeType,
    });
  } catch (error) {
    console.error('Error fetching profitability stats:', error);
    res.status(500).json({ error: 'Failed to fetch profitability stats.' });
  }
});